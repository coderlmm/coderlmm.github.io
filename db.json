{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":1,"renderable":0},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/img/logo-256.png","path":"img/logo-256.png","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/img/qrcode_256.jpg","path":"img/qrcode_256.jpg","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/archive.styl","path":"css/archive.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/beantech.css","path":"css/beantech.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/beantech.min.css","path":"css/beantech.min.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/donate.css","path":"css/donate.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/customize.css","path":"css/customize.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/toc.styl","path":"css/toc.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/rocket.styl","path":"css/rocket.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/signature.styl","path":"css/signature.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/widget.styl","path":"css/widget.styl","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/hux-blog.js","path":"js/hux-blog.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/toc.js","path":"js/toc.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/bootstrap.js","path":"js/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"source/img/header_img/archive-bak.jpg","path":"img/header_img/archive-bak.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/archives-widget.jpg","path":"img/header_img/archives-widget.jpg","modified":1,"renderable":0},{"_id":"source/img/signature/BeanTechSign-white.png","path":"img/signature/BeanTechSign-white.png","modified":1,"renderable":0},{"_id":"themes/huweihuang/source/css/images/ironman.png","path":"css/images/ironman.png","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/images/rocket.png","path":"css/images/rocket.png","modified":1,"renderable":1},{"_id":"themes/huweihuang/source/css/bootstrap.css","path":"css/bootstrap.css","modified":1,"renderable":1},{"_id":"source/img/avatar/ironman.png","path":"img/avatar/ironman.png","modified":1,"renderable":0},{"_id":"source/img/signature/BeanTechSign-black.png","path":"img/signature/BeanTechSign-black.png","modified":1,"renderable":0},{"_id":"source/img/article_header/article_bg=bak.jpg","path":"img/article_header/article_bg=bak.jpg","modified":1,"renderable":0},{"_id":"themes/huweihuang/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1},{"_id":"source/img/article_header/article_bg.jpg","path":"img/article_header/article_bg.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/tag.png","path":"img/header_img/tag.png","modified":1,"renderable":0},{"_id":"source/img/header_img/about.jpg","path":"img/header_img/about.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/archive.jpg","path":"img/header_img/archive.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/home.jpg","path":"img/header_img/home.jpg","modified":1,"renderable":0},{"_id":"source/img/header_img/tag-bak.png","path":"img/header_img/tag-bak.png","modified":1,"renderable":0},{"_id":"source/img/article_header/article_header.png","path":"img/article_header/article_header.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":1,"renderable":0},{"_id":"source/img/header_img/home2.png","path":"img/header_img/home2.png","modified":1,"renderable":0},{"_id":"source/img/header_img/404.png","path":"img/header_img/404.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"6814b69c715084cd58dfb94df9c9496b276a2960","modified":1612442109527},{"_id":"source/404.md","hash":"8aa56af7bcd7cd23667cbf3eb5b5c9fa4533eb60","modified":1611545151221},{"_id":"themes/huweihuang/_config.yml","hash":"e800e32847df32dacddb5202823a004557023bcd","modified":1611545151333},{"_id":"themes/huweihuang/.DS_Store","hash":"b15310196c00198ea018ddd504e4cceb427fa2cc","modified":1611624709909},{"_id":"themes/huweihuang/modify.md","hash":"4687ae237cb50c7178b94e01fe5f8daded8bb158","modified":1612437803146},{"_id":"source/about/index.md","hash":"08edb3a7f1516d376c0e3ebb686fe2a823fea05f","modified":1612194944799},{"_id":"source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1612196747524},{"_id":"source/tags/index.md","hash":"f6ad1039c242795de5cd7d81781148f8c5298c28","modified":1611545151333},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1611545151327},{"_id":"source/_posts/network-02-01.md","hash":"feaa3c57315d4ee1d5eb51aa7fb6d6e9ebe2b6df","modified":1612430159511},{"_id":"source/_posts/network-01.md","hash":"7fb8065df4785ca16dc46e75b14ef3271f23be27","modified":1612430141332},{"_id":"source/_posts/network-02-02.md","hash":"8e868e4fc50358825afd6fff1ccb4c0af9fee902","modified":1612430281334},{"_id":"source/_posts/.DS_Store","hash":"c6da8946440b8837ce43227ba74cce927aa7db5c","modified":1612439271515},{"_id":"source/_posts/network-03-01.md","hash":"c851f30685324d987af9173fa170680b2e22852b","modified":1612431089088},{"_id":"source/_posts/network-05-01.md","hash":"d13b98b3d050dd80b019404ed70b6396d5d44c78","modified":1612430323131},{"_id":"source/_posts/network-03-02.md","hash":"cd8df67b91f98e89e69757837918e1f0a805b410","modified":1612430299483},{"_id":"source/_posts/network-04.md","hash":"a29f9fc4ae2bac85572e9db7d9b9aca26b49114c","modified":1612431116479},{"_id":"source/archive/index.md","hash":"40c6d6d8a40f8133e48eaf8111df4a361d6ac30d","modified":1611545151232},{"_id":"themes/huweihuang/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1611545151333},{"_id":"source/_posts/network-05-02.md","hash":"1a525d49311dffe16780b326aa60da6c6dc1664c","modified":1612430348153},{"_id":"themes/huweihuang/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1611545151334},{"_id":"source/_posts/network-08.md","hash":"366667a676f12d636728b496dc6cecb769236d0f","modified":1612430361788},{"_id":"themes/huweihuang/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1611545151333},{"_id":"themes/huweihuang/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1611545151334},{"_id":"themes/huweihuang/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1611545151334},{"_id":"themes/huweihuang/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1611545151334},{"_id":"themes/huweihuang/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1611545151334},{"_id":"themes/huweihuang/layout/404.ejs","hash":"40de38bd399f6f4aef0d6c63c7b13b02d74f1c56","modified":1611545151335},{"_id":"themes/huweihuang/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1611545151334},{"_id":"themes/huweihuang/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1611545151334},{"_id":"themes/huweihuang/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1611545151337},{"_id":"themes/huweihuang/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1611545151338},{"_id":"themes/huweihuang/layout/layout.ejs","hash":"a5af5b99ac3456ab5da1a319455904b979b91601","modified":1611545151338},{"_id":"themes/huweihuang/layout/page.ejs","hash":"5e588f200a7b7cd3ae40402b0dd3b779aac6787f","modified":1611545151338},{"_id":"themes/huweihuang/layout/archive.ejs","hash":"61a3a41f35b625326ae8dc871c19406c3c00830e","modified":1612250835523},{"_id":"themes/huweihuang/layout/index.ejs","hash":"0861dcf14554fc673362d2911a59f6fa11812c07","modified":1612239171678},{"_id":"themes/huweihuang/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1611545151339},{"_id":"themes/huweihuang/layout/post.ejs","hash":"38bc622a317e8ccb55f2f3363915bb707bf3739b","modified":1612192476665},{"_id":"themes/huweihuang/source/.DS_Store","hash":"34d02cff17cde8729239c35af451ce13c8aea895","modified":1612184504308},{"_id":"source/img/header_img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1612196748523},{"_id":"themes/huweihuang/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1611545151335},{"_id":"themes/huweihuang/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1611545151336},{"_id":"themes/huweihuang/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1611545151336},{"_id":"themes/huweihuang/layout/_partial/toc.ejs","hash":"40e11b303df113c64a5ca35b79dd53c824010c09","modified":1611545151336},{"_id":"themes/huweihuang/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1611545151336},{"_id":"themes/huweihuang/layout/_widget/featured-tags.ejs","hash":"0c9ce1942f1943dc8891a9302a922ef1ffe300c5","modified":1611545151337},{"_id":"themes/huweihuang/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1611545151336},{"_id":"themes/huweihuang/layout/_widget/recent-posts.ejs","hash":"e08ab8ba60e31638006acf27f066b989a0a3c433","modified":1611545151337},{"_id":"themes/huweihuang/layout/_partial/footer.ejs","hash":"efa754caa7427b899145875f1bca96f8e964aa7d","modified":1612187107595},{"_id":"themes/huweihuang/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1611545151337},{"_id":"themes/huweihuang/layout/_partial/head.ejs","hash":"32400a15159796690329e10e261befad151e1daf","modified":1612259834558},{"_id":"themes/huweihuang/layout/_partial/header.ejs","hash":"385dd7757411693dbf056437767f11db3452b759","modified":1612239259336},{"_id":"themes/huweihuang/layout/_widget/short-about.ejs","hash":"315de02246f07c747c32495e107ad7b19cb3ff54","modified":1611627254366},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1611545151343},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1611545151344},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1611545151344},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1611545151344},{"_id":"themes/huweihuang/source/img/logo-256.png","hash":"4db8557b38dc7187ab4b68c9e2380e82a7c09eaa","modified":1611547796130},{"_id":"themes/huweihuang/source/img/qrcode_256.jpg","hash":"1b6495ff55255495946eaf340e899cf76fc415b6","modified":1611547796127},{"_id":"themes/huweihuang/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1611545151339},{"_id":"themes/huweihuang/source/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1611545151339},{"_id":"themes/huweihuang/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1611545151340},{"_id":"themes/huweihuang/source/css/donate.css","hash":"f65ac8363d8d215adb896158e7b45165db259a47","modified":1611545151341},{"_id":"themes/huweihuang/source/css/customize.css","hash":"a6592a346804a74e876cc2060205bff640caf4a0","modified":1612437587107},{"_id":"themes/huweihuang/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1611545151341},{"_id":"themes/huweihuang/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1611545151341},{"_id":"themes/huweihuang/source/css/toc.styl","hash":"631e97f634d30f53314e2fec8bdde267c1c49f4c","modified":1611545151342},{"_id":"themes/huweihuang/source/css/rocket.styl","hash":"e15c51c8566ecd943112e57592888dd318b6fa6a","modified":1611545151342},{"_id":"themes/huweihuang/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1611545151342},{"_id":"themes/huweihuang/source/css/widget.styl","hash":"7a9f735f5ef323dc2950fbd9d76daa16c9a0f1a9","modified":1612179816886},{"_id":"themes/huweihuang/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1611545151345},{"_id":"themes/huweihuang/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1611545151345},{"_id":"themes/huweihuang/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1611545151346},{"_id":"themes/huweihuang/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1611545151349},{"_id":"themes/huweihuang/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1611545151349},{"_id":"themes/huweihuang/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1611545151349},{"_id":"themes/huweihuang/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1611545151350},{"_id":"themes/huweihuang/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1611545151343},{"_id":"themes/huweihuang/source/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1611545151341},{"_id":"themes/huweihuang/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1611545151345},{"_id":"themes/huweihuang/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1611545151349},{"_id":"source/img/header_img/archive-bak.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1611545151281},{"_id":"source/img/header_img/archives-widget.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1611545151283},{"_id":"source/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1611545151332},{"_id":"themes/huweihuang/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1611545151342},{"_id":"themes/huweihuang/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1611545151342},{"_id":"themes/huweihuang/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1612179650957},{"_id":"source/img/avatar/ironman.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1611545151253},{"_id":"source/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1611545151331},{"_id":"source/img/article_header/article_bg=bak.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1611545151247},{"_id":"themes/huweihuang/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1611545151348},{"_id":"source/img/article_header/article_bg.jpg","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1611545151300},{"_id":"source/img/header_img/tag.png","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1611545151300},{"_id":"source/img/header_img/about.jpg","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1611545151300},{"_id":"source/img/header_img/archive.jpg","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1611545151300},{"_id":"source/img/header_img/home.jpg","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1611545151300},{"_id":"source/img/header_img/tag-bak.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1611545151327},{"_id":"source/img/article_header/article_header.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1611545151250},{"_id":"source/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1611545151296},{"_id":"source/img/header_img/home2.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1611545151316},{"_id":"source/img/header_img/404.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1611545151275},{"_id":"public/post-sitemap.xml","hash":"0a7d332fe79b62fc403b53035d6b95fc1807859f","modified":1612442726092},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1612442726114},{"_id":"public/page-sitemap.xml","hash":"553f957c7ef3c0c79bb8511be0d6bdc3d2ca4104","modified":1612442726127},{"_id":"public/tag-sitemap.xml","hash":"40288fce4e3c433837ec528b9b7b1c84f50af7dc","modified":1612442726128},{"_id":"public/sitemap.xml","hash":"a4e8b663f6cd622d2c693e10e7f38c11761f59c7","modified":1612442726128},{"_id":"public/404.html","hash":"d218c1a1863efad8a65265182e78f40eedc5952b","modified":1612442726133},{"_id":"public/about/index.html","hash":"3be5c129b0257ed92a8d2af7445a5f771b27ab61","modified":1612442726133},{"_id":"public/tags/index.html","hash":"6060afc1fda7b85d64ca3d08c2802e7384f1aa21","modified":1612442726133},{"_id":"public/article/network-08/index.html","hash":"c7099d9768baf280b3c149938823cfce7a68b751","modified":1612442726133},{"_id":"public/article/network-05-02/index.html","hash":"1304615750ec29d21fef7cb2029b10806484b3b7","modified":1612442726133},{"_id":"public/article/network-05-01/index.html","hash":"e0206220c804020083ffcd864ae1dff3dd5db163","modified":1612442726133},{"_id":"public/article/network-04/index.html","hash":"c3a3f901399681f3bd0ec8d3eaf51685a38d816c","modified":1612442726133},{"_id":"public/article/network-03-01/index.html","hash":"47121e8b0711cd509456cd889096901aa1a0b1f9","modified":1612442726133},{"_id":"public/article/network-03-02/index.html","hash":"b1e6ef3725aae5e4c98e3d4c6db4711338b92901","modified":1612442726133},{"_id":"public/article/network-02-02/index.html","hash":"7d197b66bab979de319cceefb92317f18f04d20f","modified":1612442726134},{"_id":"public/article/network-02-01/index.html","hash":"69d61e5fefd740ba1f32e76957421e044e1c815a","modified":1612442726134},{"_id":"public/article/network-01/index.html","hash":"ead4beeb3eafd39d8c7873a66b724122cd873c0c","modified":1612442726134},{"_id":"public/archive/index.html","hash":"ded71e2d782d9061819df2ff6e3f9bfccb0e01ea","modified":1612442726134},{"_id":"public/archives/index.html","hash":"6445f8d2c4186e667a69004a0bcc78dfb6f3325d","modified":1612442726134},{"_id":"public/archives/2019/index.html","hash":"069c362e485273ee6929567c28c679345efca587","modified":1612442726134},{"_id":"public/archives/2019/05/index.html","hash":"c4d4fc0c70b6bbe5165b9000b47ab6001541280f","modified":1612442726134},{"_id":"public/archives/2019/06/index.html","hash":"4622c77f1e5ca7dbd4897df0d50f27455dd521c6","modified":1612442726134},{"_id":"public/index.html","hash":"ef46f020926c65b888be0f781ecfbe37cb31d4e1","modified":1612442726134},{"_id":"public/tags/network/index.html","hash":"8e8ad1abeae02ded3f856e7a23ef5aa15dc0b141","modified":1612442726134},{"_id":"public/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1612442726138},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1612442726139},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1612442726139},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1612442726139},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1612442726139},{"_id":"public/img/logo-256.png","hash":"4db8557b38dc7187ab4b68c9e2380e82a7c09eaa","modified":1612442726139},{"_id":"public/img/qrcode_256.jpg","hash":"1b6495ff55255495946eaf340e899cf76fc415b6","modified":1612442726139},{"_id":"public/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1612442726139},{"_id":"public/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1612442726139},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1612442726348},{"_id":"public/css/archive.css","hash":"8db895ebaeff19ac145c961abcfd5d4a8d67a8ea","modified":1612442726355},{"_id":"public/css/donate.css","hash":"f65ac8363d8d215adb896158e7b45165db259a47","modified":1612442726355},{"_id":"public/css/highlight.css","hash":"c58b4569c086e477a00dcbf5a95a166fe5fecfb0","modified":1612442726355},{"_id":"public/css/customize.css","hash":"a6592a346804a74e876cc2060205bff640caf4a0","modified":1612442726355},{"_id":"public/css/rocket.css","hash":"9456fd92f729e09d6de8cda70f95d78e0d789c70","modified":1612442726355},{"_id":"public/css/toc.css","hash":"f756b9e1b2208d2e5b0f3d2ac5e4fea3b7da0e10","modified":1612442726355},{"_id":"public/css/widget.css","hash":"da95ad3f1938f24d20f1fa77d7a38f0c392b5ec8","modified":1612442726355},{"_id":"public/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1612442726355},{"_id":"public/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1612442726355},{"_id":"public/css/signature.css","hash":"820fa4743cea34a61808cd8f7de528605c32d7e3","modified":1612442726355},{"_id":"public/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1612442726356},{"_id":"public/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1612442726356},{"_id":"public/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1612442726356},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1612442726356},{"_id":"public/img/header_img/archive-bak.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1612442726356},{"_id":"public/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1612442726356},{"_id":"public/img/header_img/archives-widget.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1612442726361},{"_id":"public/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1612442726366},{"_id":"public/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1612442726366},{"_id":"public/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1612442726366},{"_id":"public/img/avatar/ironman.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1612442726366},{"_id":"public/img/article_header/article_bg=bak.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1612442726368},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1612442726371},{"_id":"public/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1612442726371},{"_id":"public/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1612442726382},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1612442726384},{"_id":"public/img/header_img/about.jpg","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1612442726384},{"_id":"public/img/header_img/tag.png","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1612442726385},{"_id":"public/img/header_img/archive.jpg","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1612442726385},{"_id":"public/img/header_img/home.jpg","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1612442726386},{"_id":"public/img/article_header/article_bg.jpg","hash":"8f1c440427a4aa86b623503a926c027e2e10cd66","modified":1612442726388},{"_id":"public/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1612442726392},{"_id":"public/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1612442726397},{"_id":"public/img/header_img/tag-bak.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1612442726404},{"_id":"public/img/article_header/article_header.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1612442726409},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1612442726421},{"_id":"public/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1612442726425},{"_id":"public/img/header_img/home2.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1612442726429},{"_id":"public/img/header_img/404.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1612442726434}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原","header-img":"/img/header_img/404.png","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原\"\nheader-img: \"/img/header_img/404.png\"\n---\n","date":"2021-02-04T12:30:21.498Z","updated":"2021-01-25T03:25:51.221Z","path":"404.html","title":"","comments":1,"_id":"ckkqurluk0000rca7mh1ruzjz","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2017-10-03T02:48:33.000Z","description":"","header-img":"/img/header_img/about.jpg","aplayer":true,"fixed":false,"_content":"\n### 座右铭\n\n> 勿在浮沙筑高台\n\n### 关于我\n\n> 你好，朋友们都叫我豆豆。\n> 爱开源，爱户外，爱生活，一个有点偏执的谷歌粉。\n> 这里不仅仅是技术的堆砌，更是我漫漫人生路的记载。\n> 博客内容除非特殊声明，博客内容皆为个人原创，转载烦请标注文章来源。\n> 博客采用 [Hexo](https://hexo.io/) 搭建，主题是在 [huweihuang](https://github.com/huweihuang/hexo-theme-huweihuang) 的基础上做了些许修改，在此感谢下作者。\n\n### 联系我\n\n>Email: coderlmm@gmail.com\n\n<br/>\n\n<center>欢迎关注我的公众号：豆豆的杂货铺</center>\n<br/>\n<center>始于技术，但不止于技术。</center>\n\n![](/img/qrcode_256.jpg)\n\n\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2017-10-03 10:48:33\ndescription: \"\"\nheader-img: \"/img/header_img/about.jpg\"\naplayer: true\nfixed: false\n---\n\n### 座右铭\n\n> 勿在浮沙筑高台\n\n### 关于我\n\n> 你好，朋友们都叫我豆豆。\n> 爱开源，爱户外，爱生活，一个有点偏执的谷歌粉。\n> 这里不仅仅是技术的堆砌，更是我漫漫人生路的记载。\n> 博客内容除非特殊声明，博客内容皆为个人原创，转载烦请标注文章来源。\n> 博客采用 [Hexo](https://hexo.io/) 搭建，主题是在 [huweihuang](https://github.com/huweihuang/hexo-theme-huweihuang) 的基础上做了些许修改，在此感谢下作者。\n\n### 联系我\n\n>Email: coderlmm@gmail.com\n\n<br/>\n\n<center>欢迎关注我的公众号：豆豆的杂货铺</center>\n<br/>\n<center>始于技术，但不止于技术。</center>\n\n![](/img/qrcode_256.jpg)\n\n\n","updated":"2021-02-01T15:55:44.799Z","path":"about/index.html","comments":1,"_id":"ckkqurlv90001rca7vd6h8avi","content":"<h3 id=\"座右铭\">座右铭</h3>\n<blockquote>\n<p>勿在浮沙筑高台</p>\n</blockquote>\n<h3 id=\"关于我\">关于我</h3>\n<blockquote>\n<p>你好，朋友们都叫我豆豆。<br>\n爱开源，爱户外，爱生活，一个有点偏执的谷歌粉。<br>\n这里不仅仅是技术的堆砌，更是我漫漫人生路的记载。<br>\n博客内容除非特殊声明，博客内容皆为个人原创，转载烦请标注文章来源。<br>\n博客采用 <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a> 搭建，主题是在 <a href=\"https://github.com/huweihuang/hexo-theme-huweihuang\" target=\"_blank\" rel=\"noopener\">huweihuang</a> 的基础上做了些许修改，在此感谢下作者。</p>\n</blockquote>\n<h3 id=\"联系我\">联系我</h3>\n<blockquote>\n<p>Email: <a href=\"mailto:coderlmm@gmail.com\" target=\"_blank\" rel=\"noopener\">coderlmm@gmail.com</a></p>\n</blockquote>\n<br>\n<center>欢迎关注我的公众号：豆豆的杂货铺</center>\n<br>\n<center>始于技术，但不止于技术。</center>\n<p><img src=\"/img/qrcode_256.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3>座右铭</h3>\n<blockquote>\n<p>勿在浮沙筑高台</p>\n</blockquote>\n<h3>关于我</h3>\n<blockquote>\n<p>你好，朋友们都叫我豆豆。<br>\n爱开源，爱户外，爱生活，一个有点偏执的谷歌粉。<br>\n这里不仅仅是技术的堆砌，更是我漫漫人生路的记载。<br>\n博客内容除非特殊声明，博客内容皆为个人原创，转载烦请标注文章来源。<br>\n博客采用 <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a> 搭建，主题是在 <a href=\"https://github.com/huweihuang/hexo-theme-huweihuang\" target=\"_blank\" rel=\"noopener\">huweihuang</a> 的基础上做了些许修改，在此感谢下作者。</p>\n</blockquote>\n<h3>联系我</h3>\n<blockquote>\n<p>Email: <a href=\"mailto:coderlmm@gmail.com\" target=\"_blank\" rel=\"noopener\">coderlmm@gmail.com</a></p>\n</blockquote>\n<br>\n<center>欢迎关注我的公众号：豆豆的杂货铺</center>\n<br>\n<center>始于技术，但不止于技术。</center>\n<p><img src=\"/img/qrcode_256.jpg\" alt=\"\"></p>\n"},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"/img/header_img/tag.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"/img/header_img/tag.png\"\n---\n","date":"2021-02-04T12:30:21.487Z","updated":"2021-01-25T03:25:51.333Z","path":"tags/index.html","comments":1,"_id":"ckkqurlve0003rca7tuhf9qmm","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"archive","title":"Archives","header-img":"/img/header_img/archive.jpg","comments":0,"date":"2017-09-20T12:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"/img/header_img/archive.jpg\"\ncomments: false\ndate: 2017-09-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2021-01-25T03:25:51.232Z","path":"archive/index.html","_id":"ckkqurlvh0006rca7sgg0o7al","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"计算机网络自顶向下方法读书笔记（第二章之一）","date":"2019-05-09T16:00:00.000Z","catalog":true,"_content":"\n客户--服务器体系结构，有一个总是打开的主机成为服务器。具有固定的，周知的 IP 地址。\n\n### 进程通信\n\n不同主机间的进程通信。\n\n网络进程通信，很明显至少是两个进程，他们通过网络互相发送报文。若想通过网络发送报文，报文则必须经过发送方的应用层 -> 运输层 -> 网络层 -> 链路层 -> 物理层，再到接收方物理层 -> 链路层 -> 网络层 -> 运输层 -> 应用层，方而完成报文的发送和接收。就好比你从一栋大楼的最高层去往隔壁大楼的最高层一样，肯定要先下到底面，然后在从底面上去隔壁楼。\n\n问题来了，应用层是如何和传输层发送数据交换的呢，套接字。这是一个软件接口，是同一台主机内应用层与传输层之间的接口，也叫「应用程序编程接口」。现在知道怎么发送了，那接收方的地址怎么确定呢，一个是主机地址，一个是应用程序地址，答案就是 **IP 地址 + 端口号**。这样接收方接受到数据时就可以根据端口号进行数据分发了。\n\n选择传输协议时需注意以下几点：\n\n1. 可靠数据传输，就是数据能否一定到达目的地\n2. 吞吐量\n3. 定时（笔者不太晓得这个定时啥用处）\n4. 安全性\n\n运输层跑的协议主要是 TCP 协议，该协议是面向连接的，可靠的数据传输协议。安全性可以通过 SSL 来保证。注意，SSL 不是与 TCP/UDP 在相同层次上的第三种运输协议，而是一种对 TCP 的加强。\n\nUDP 是无连接的，不可靠数据传输服务，同时有可能是乱序的。\n\n**今天的因特网通常可以为时间敏感应用提供满意的服务，但它不能提供任何定时和带宽保证。**\n\n### 应用层协议\n\n应用层使用最广泛的便是 HTTP 协议，也叫超文本传输协议。该协议是无状态的，但是可以通过标识码即 sessionID 来表示会话信息，这得益于返回的 Set-cookie 机制。\n\nFTP 协议使用两个并行的 TCP 连接来传输文件，一个用于控制连接，一个用于数据连接。FTP 服务器必须在整个会话期间保留用户的状态。\n\nSMTP 电子邮件协议。\n\nSMTP 不使用中间邮件服务器，A 邮件客户端 --> A 邮件服务器 --> B 邮件服务器 --> B 邮件客户端。\n\n「A 邮件服务器 --> B 邮件服务器」的过程通过 SMTP 协议推过去，因为是 A 发起的连接。这也是 SMTP 和 HTTP 的主要差别，HTTP 主要是由获取文件方发起连接请求，属于**拉协议**，SMTP 主要是由发送文件方发起连接，属于**推协议**。\n\n第二个区别就是 SMTP 要求每一个报文使用 7 比特的 ASCII 码格式。","source":"_posts/network-02-01.md","raw":"---\ntitle: 计算机网络自顶向下方法读书笔记（第二章之一）\ndate: 2019-05-10\ntags: \n    - network\ncatalog: true\n---\n\n客户--服务器体系结构，有一个总是打开的主机成为服务器。具有固定的，周知的 IP 地址。\n\n### 进程通信\n\n不同主机间的进程通信。\n\n网络进程通信，很明显至少是两个进程，他们通过网络互相发送报文。若想通过网络发送报文，报文则必须经过发送方的应用层 -> 运输层 -> 网络层 -> 链路层 -> 物理层，再到接收方物理层 -> 链路层 -> 网络层 -> 运输层 -> 应用层，方而完成报文的发送和接收。就好比你从一栋大楼的最高层去往隔壁大楼的最高层一样，肯定要先下到底面，然后在从底面上去隔壁楼。\n\n问题来了，应用层是如何和传输层发送数据交换的呢，套接字。这是一个软件接口，是同一台主机内应用层与传输层之间的接口，也叫「应用程序编程接口」。现在知道怎么发送了，那接收方的地址怎么确定呢，一个是主机地址，一个是应用程序地址，答案就是 **IP 地址 + 端口号**。这样接收方接受到数据时就可以根据端口号进行数据分发了。\n\n选择传输协议时需注意以下几点：\n\n1. 可靠数据传输，就是数据能否一定到达目的地\n2. 吞吐量\n3. 定时（笔者不太晓得这个定时啥用处）\n4. 安全性\n\n运输层跑的协议主要是 TCP 协议，该协议是面向连接的，可靠的数据传输协议。安全性可以通过 SSL 来保证。注意，SSL 不是与 TCP/UDP 在相同层次上的第三种运输协议，而是一种对 TCP 的加强。\n\nUDP 是无连接的，不可靠数据传输服务，同时有可能是乱序的。\n\n**今天的因特网通常可以为时间敏感应用提供满意的服务，但它不能提供任何定时和带宽保证。**\n\n### 应用层协议\n\n应用层使用最广泛的便是 HTTP 协议，也叫超文本传输协议。该协议是无状态的，但是可以通过标识码即 sessionID 来表示会话信息，这得益于返回的 Set-cookie 机制。\n\nFTP 协议使用两个并行的 TCP 连接来传输文件，一个用于控制连接，一个用于数据连接。FTP 服务器必须在整个会话期间保留用户的状态。\n\nSMTP 电子邮件协议。\n\nSMTP 不使用中间邮件服务器，A 邮件客户端 --> A 邮件服务器 --> B 邮件服务器 --> B 邮件客户端。\n\n「A 邮件服务器 --> B 邮件服务器」的过程通过 SMTP 协议推过去，因为是 A 发起的连接。这也是 SMTP 和 HTTP 的主要差别，HTTP 主要是由获取文件方发起连接请求，属于**拉协议**，SMTP 主要是由发送文件方发起连接，属于**推协议**。\n\n第二个区别就是 SMTP 要求每一个报文使用 7 比特的 ASCII 码格式。","slug":"network-02-01","published":1,"updated":"2021-02-04T09:15:59.511Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqurlva0002rca7wrryycz7","content":"<p>客户–服务器体系结构，有一个总是打开的主机成为服务器。具有固定的，周知的 IP 地址。</p>\n<h3 id=\"进程通信\">进程通信</h3>\n<p>不同主机间的进程通信。</p>\n<p>网络进程通信，很明显至少是两个进程，他们通过网络互相发送报文。若想通过网络发送报文，报文则必须经过发送方的应用层 -&gt; 运输层 -&gt; 网络层 -&gt; 链路层 -&gt; 物理层，再到接收方物理层 -&gt; 链路层 -&gt; 网络层 -&gt; 运输层 -&gt; 应用层，方而完成报文的发送和接收。就好比你从一栋大楼的最高层去往隔壁大楼的最高层一样，肯定要先下到底面，然后在从底面上去隔壁楼。</p>\n<p>问题来了，应用层是如何和传输层发送数据交换的呢，套接字。这是一个软件接口，是同一台主机内应用层与传输层之间的接口，也叫「应用程序编程接口」。现在知道怎么发送了，那接收方的地址怎么确定呢，一个是主机地址，一个是应用程序地址，答案就是 <strong>IP 地址 + 端口号</strong>。这样接收方接受到数据时就可以根据端口号进行数据分发了。</p>\n<p>选择传输协议时需注意以下几点：</p>\n<ol>\n<li>可靠数据传输，就是数据能否一定到达目的地</li>\n<li>吞吐量</li>\n<li>定时（笔者不太晓得这个定时啥用处）</li>\n<li>安全性</li>\n</ol>\n<p>运输层跑的协议主要是 TCP 协议，该协议是面向连接的，可靠的数据传输协议。安全性可以通过 SSL 来保证。注意，SSL 不是与 TCP/UDP 在相同层次上的第三种运输协议，而是一种对 TCP 的加强。</p>\n<p>UDP 是无连接的，不可靠数据传输服务，同时有可能是乱序的。</p>\n<p><strong>今天的因特网通常可以为时间敏感应用提供满意的服务，但它不能提供任何定时和带宽保证。</strong></p>\n<h3 id=\"应用层协议\">应用层协议</h3>\n<p>应用层使用最广泛的便是 HTTP 协议，也叫超文本传输协议。该协议是无状态的，但是可以通过标识码即 sessionID 来表示会话信息，这得益于返回的 Set-cookie 机制。</p>\n<p>FTP 协议使用两个并行的 TCP 连接来传输文件，一个用于控制连接，一个用于数据连接。FTP 服务器必须在整个会话期间保留用户的状态。</p>\n<p>SMTP 电子邮件协议。</p>\n<p>SMTP 不使用中间邮件服务器，A 邮件客户端 --&gt; A 邮件服务器 --&gt; B 邮件服务器 --&gt; B 邮件客户端。</p>\n<p>「A 邮件服务器 --&gt; B 邮件服务器」的过程通过 SMTP 协议推过去，因为是 A 发起的连接。这也是 SMTP 和 HTTP 的主要差别，HTTP 主要是由获取文件方发起连接请求，属于<strong>拉协议</strong>，SMTP 主要是由发送文件方发起连接，属于<strong>推协议</strong>。</p>\n<p>第二个区别就是 SMTP 要求每一个报文使用 7 比特的 ASCII 码格式。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>客户–服务器体系结构，有一个总是打开的主机成为服务器。具有固定的，周知的 IP 地址。</p>\n<h3>进程通信</h3>\n<p>不同主机间的进程通信。</p>\n<p>网络进程通信，很明显至少是两个进程，他们通过网络互相发送报文。若想通过网络发送报文，报文则必须经过发送方的应用层 -&gt; 运输层 -&gt; 网络层 -&gt; 链路层 -&gt; 物理层，再到接收方物理层 -&gt; 链路层 -&gt; 网络层 -&gt; 运输层 -&gt; 应用层，方而完成报文的发送和接收。就好比你从一栋大楼的最高层去往隔壁大楼的最高层一样，肯定要先下到底面，然后在从底面上去隔壁楼。</p>\n<p>问题来了，应用层是如何和传输层发送数据交换的呢，套接字。这是一个软件接口，是同一台主机内应用层与传输层之间的接口，也叫「应用程序编程接口」。现在知道怎么发送了，那接收方的地址怎么确定呢，一个是主机地址，一个是应用程序地址，答案就是 <strong>IP 地址 + 端口号</strong>。这样接收方接受到数据时就可以根据端口号进行数据分发了。</p>\n<p>选择传输协议时需注意以下几点：</p>\n<ol>\n<li>可靠数据传输，就是数据能否一定到达目的地</li>\n<li>吞吐量</li>\n<li>定时（笔者不太晓得这个定时啥用处）</li>\n<li>安全性</li>\n</ol>\n<p>运输层跑的协议主要是 TCP 协议，该协议是面向连接的，可靠的数据传输协议。安全性可以通过 SSL 来保证。注意，SSL 不是与 TCP/UDP 在相同层次上的第三种运输协议，而是一种对 TCP 的加强。</p>\n<p>UDP 是无连接的，不可靠数据传输服务，同时有可能是乱序的。</p>\n<p><strong>今天的因特网通常可以为时间敏感应用提供满意的服务，但它不能提供任何定时和带宽保证。</strong></p>\n<h3>应用层协议</h3>\n<p>应用层使用最广泛的便是 HTTP 协议，也叫超文本传输协议。该协议是无状态的，但是可以通过标识码即 sessionID 来表示会话信息，这得益于返回的 Set-cookie 机制。</p>\n<p>FTP 协议使用两个并行的 TCP 连接来传输文件，一个用于控制连接，一个用于数据连接。FTP 服务器必须在整个会话期间保留用户的状态。</p>\n<p>SMTP 电子邮件协议。</p>\n<p>SMTP 不使用中间邮件服务器，A 邮件客户端 --&gt; A 邮件服务器 --&gt; B 邮件服务器 --&gt; B 邮件客户端。</p>\n<p>「A 邮件服务器 --&gt; B 邮件服务器」的过程通过 SMTP 协议推过去，因为是 A 发起的连接。这也是 SMTP 和 HTTP 的主要差别，HTTP 主要是由获取文件方发起连接请求，属于<strong>拉协议</strong>，SMTP 主要是由发送文件方发起连接，属于<strong>推协议</strong>。</p>\n<p>第二个区别就是 SMTP 要求每一个报文使用 7 比特的 ASCII 码格式。</p>\n"},{"title":"计算机网络自顶向下方法读书笔记（第一章）","date":"2019-05-02T16:00:00.000Z","catalog":true,"_content":"\n2019.05.13 号周一开始了第三期的读书活动「计算机网络自顶向下方法」，由于自己拖延加上后来流感感染高烧感冒导致现在才开始动笔写作业，甚是惭愧。\n\n本章简单，多是概念性的知识。\n\n网络中的是设备通过通信链路和分组交换机链接到一起，其中各个设备要想完成信息交换，也就是数据的传输，必须有一个统一的协议才行。就好比人们平时沟通交流所用的语言一样，语言不通，沟通的可能性基本为零。\n\n因特网中设计的协议非常多，比如硬件实现的协议控制了在两块网卡间的比特流，拥塞控制协议控制了发送方和接收方之间的传输速率，但其中最重要的两个协议还属 TCP 和 IP 协议。\n\n两台计算机之间若想进行数据交换，则必须相连，现实生活中的设备千千万，如果每两两相连的话则不太可能，于是出现分组交换技术。这真是一项伟大的发明。\n\n### 协议层次\n\n五层因特网协议栈：应用层，运输层，网络层，链路层，物理层。\n\n七层 OSI 参考模型：应用层，表示层，会话层，运输层，网络层，链路层，物理层。\n\n分层带来的最大的好处就是可以分而治之，各层之间不相互依赖其具体实现，只要每层做好自己分内的事就可以了。\n\n### 网络攻击\n\n+ 病毒可以入住主机\n+ DoS 攻击\n+ 网络中传输的数据包有可能被截获\n+ IP 哄骗","source":"_posts/network-01.md","raw":"---\ntitle: 计算机网络自顶向下方法读书笔记（第一章）\ndate: 2019-05-03\ntags: \n    - network\ncatalog: true\n---\n\n2019.05.13 号周一开始了第三期的读书活动「计算机网络自顶向下方法」，由于自己拖延加上后来流感感染高烧感冒导致现在才开始动笔写作业，甚是惭愧。\n\n本章简单，多是概念性的知识。\n\n网络中的是设备通过通信链路和分组交换机链接到一起，其中各个设备要想完成信息交换，也就是数据的传输，必须有一个统一的协议才行。就好比人们平时沟通交流所用的语言一样，语言不通，沟通的可能性基本为零。\n\n因特网中设计的协议非常多，比如硬件实现的协议控制了在两块网卡间的比特流，拥塞控制协议控制了发送方和接收方之间的传输速率，但其中最重要的两个协议还属 TCP 和 IP 协议。\n\n两台计算机之间若想进行数据交换，则必须相连，现实生活中的设备千千万，如果每两两相连的话则不太可能，于是出现分组交换技术。这真是一项伟大的发明。\n\n### 协议层次\n\n五层因特网协议栈：应用层，运输层，网络层，链路层，物理层。\n\n七层 OSI 参考模型：应用层，表示层，会话层，运输层，网络层，链路层，物理层。\n\n分层带来的最大的好处就是可以分而治之，各层之间不相互依赖其具体实现，只要每层做好自己分内的事就可以了。\n\n### 网络攻击\n\n+ 病毒可以入住主机\n+ DoS 攻击\n+ 网络中传输的数据包有可能被截获\n+ IP 哄骗","slug":"network-01","published":1,"updated":"2021-02-04T09:15:41.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqurlve0004rca76ol33fi2","content":"<p>2019.05.13 号周一开始了第三期的读书活动「计算机网络自顶向下方法」，由于自己拖延加上后来流感感染高烧感冒导致现在才开始动笔写作业，甚是惭愧。</p>\n<p>本章简单，多是概念性的知识。</p>\n<p>网络中的是设备通过通信链路和分组交换机链接到一起，其中各个设备要想完成信息交换，也就是数据的传输，必须有一个统一的协议才行。就好比人们平时沟通交流所用的语言一样，语言不通，沟通的可能性基本为零。</p>\n<p>因特网中设计的协议非常多，比如硬件实现的协议控制了在两块网卡间的比特流，拥塞控制协议控制了发送方和接收方之间的传输速率，但其中最重要的两个协议还属 TCP 和 IP 协议。</p>\n<p>两台计算机之间若想进行数据交换，则必须相连，现实生活中的设备千千万，如果每两两相连的话则不太可能，于是出现分组交换技术。这真是一项伟大的发明。</p>\n<h3 id=\"协议层次\">协议层次</h3>\n<p>五层因特网协议栈：应用层，运输层，网络层，链路层，物理层。</p>\n<p>七层 OSI 参考模型：应用层，表示层，会话层，运输层，网络层，链路层，物理层。</p>\n<p>分层带来的最大的好处就是可以分而治之，各层之间不相互依赖其具体实现，只要每层做好自己分内的事就可以了。</p>\n<h3 id=\"网络攻击\">网络攻击</h3>\n<ul>\n<li>病毒可以入住主机</li>\n<li>DoS 攻击</li>\n<li>网络中传输的数据包有可能被截获</li>\n<li>IP 哄骗</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>2019.05.13 号周一开始了第三期的读书活动「计算机网络自顶向下方法」，由于自己拖延加上后来流感感染高烧感冒导致现在才开始动笔写作业，甚是惭愧。</p>\n<p>本章简单，多是概念性的知识。</p>\n<p>网络中的是设备通过通信链路和分组交换机链接到一起，其中各个设备要想完成信息交换，也就是数据的传输，必须有一个统一的协议才行。就好比人们平时沟通交流所用的语言一样，语言不通，沟通的可能性基本为零。</p>\n<p>因特网中设计的协议非常多，比如硬件实现的协议控制了在两块网卡间的比特流，拥塞控制协议控制了发送方和接收方之间的传输速率，但其中最重要的两个协议还属 TCP 和 IP 协议。</p>\n<p>两台计算机之间若想进行数据交换，则必须相连，现实生活中的设备千千万，如果每两两相连的话则不太可能，于是出现分组交换技术。这真是一项伟大的发明。</p>\n<h3>协议层次</h3>\n<p>五层因特网协议栈：应用层，运输层，网络层，链路层，物理层。</p>\n<p>七层 OSI 参考模型：应用层，表示层，会话层，运输层，网络层，链路层，物理层。</p>\n<p>分层带来的最大的好处就是可以分而治之，各层之间不相互依赖其具体实现，只要每层做好自己分内的事就可以了。</p>\n<h3>网络攻击</h3>\n<ul>\n<li>病毒可以入住主机</li>\n<li>DoS 攻击</li>\n<li>网络中传输的数据包有可能被截获</li>\n<li>IP 哄骗</li>\n</ul>\n"},{"title":"计算机网络自顶向下方法读书笔记（第二章之二）","date":"2019-05-16T16:00:00.000Z","_content":"\nIP 地址用于标识主机的唯一地址，但 IP 地址对人类是不友好的，难于记忆的，所以就出现了域名。因此需要一个系统可以将 IP 地址和域名进行转换，这就是域名系统（DNS）。\n\n**DNS 协议属于应用层协议，运行在 UDP 之上，使用 53 号端口。**\n\n除了域名和 IP 地址这间的转换服务外，DNS 还提供一下服务：\n\n+ 主机别名\n+ 邮件服务器别名\n+ 负载分配\n\n单一 DNS 服务器上运行集中式数据库完全没有任何扩展能力，有以下弊端。\n\n+ 单点故障：该服务器崩溃，整个因特网将瘫痪\n+ 通信容量：处理所有 DNS 查询\n+ 远距离的集中式数据库：有可能查询一次要绕半个地球\n+ 维护：添加新的记录时要频繁更新。\n\n因此，DNS 服务器采取分布式分层次数据库来对外提供服务，共分为根 DNS 服务器，顶级域 DNS 服务器，权威 DNS 服务器。\n\nDNS 数据库中的记录插入由**注册登记机构**负责。\n\nDNS 攻击主要是 DDoS 攻击和中间人攻击。\n\nTCP / UDP 套接字编程，都是要先启动服务端程序，以等待客户端的连接请求。不同的是 TCP 在发起连接之前会有一个三次握手的过程，幸运的是，这个过程对客户和程序是完全透明的，运输层会自己做这件事。","source":"_posts/network-02-02.md","raw":"---\ntitle: 计算机网络自顶向下方法读书笔记（第二章之二）\ndate: 2019-05-17\ntags: \n    - network\n---\n\nIP 地址用于标识主机的唯一地址，但 IP 地址对人类是不友好的，难于记忆的，所以就出现了域名。因此需要一个系统可以将 IP 地址和域名进行转换，这就是域名系统（DNS）。\n\n**DNS 协议属于应用层协议，运行在 UDP 之上，使用 53 号端口。**\n\n除了域名和 IP 地址这间的转换服务外，DNS 还提供一下服务：\n\n+ 主机别名\n+ 邮件服务器别名\n+ 负载分配\n\n单一 DNS 服务器上运行集中式数据库完全没有任何扩展能力，有以下弊端。\n\n+ 单点故障：该服务器崩溃，整个因特网将瘫痪\n+ 通信容量：处理所有 DNS 查询\n+ 远距离的集中式数据库：有可能查询一次要绕半个地球\n+ 维护：添加新的记录时要频繁更新。\n\n因此，DNS 服务器采取分布式分层次数据库来对外提供服务，共分为根 DNS 服务器，顶级域 DNS 服务器，权威 DNS 服务器。\n\nDNS 数据库中的记录插入由**注册登记机构**负责。\n\nDNS 攻击主要是 DDoS 攻击和中间人攻击。\n\nTCP / UDP 套接字编程，都是要先启动服务端程序，以等待客户端的连接请求。不同的是 TCP 在发起连接之前会有一个三次握手的过程，幸运的是，这个过程对客户和程序是完全透明的，运输层会自己做这件事。","slug":"network-02-02","published":1,"updated":"2021-02-04T09:18:01.334Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqurlvi0007rca7pm7grgz3","content":"<p>IP 地址用于标识主机的唯一地址，但 IP 地址对人类是不友好的，难于记忆的，所以就出现了域名。因此需要一个系统可以将 IP 地址和域名进行转换，这就是域名系统（DNS）。</p>\n<p><strong>DNS 协议属于应用层协议，运行在 UDP 之上，使用 53 号端口。</strong></p>\n<p>除了域名和 IP 地址这间的转换服务外，DNS 还提供一下服务：</p>\n<ul>\n<li>主机别名</li>\n<li>邮件服务器别名</li>\n<li>负载分配</li>\n</ul>\n<p>单一 DNS 服务器上运行集中式数据库完全没有任何扩展能力，有以下弊端。</p>\n<ul>\n<li>单点故障：该服务器崩溃，整个因特网将瘫痪</li>\n<li>通信容量：处理所有 DNS 查询</li>\n<li>远距离的集中式数据库：有可能查询一次要绕半个地球</li>\n<li>维护：添加新的记录时要频繁更新。</li>\n</ul>\n<p>因此，DNS 服务器采取分布式分层次数据库来对外提供服务，共分为根 DNS 服务器，顶级域 DNS 服务器，权威 DNS 服务器。</p>\n<p>DNS 数据库中的记录插入由<strong>注册登记机构</strong>负责。</p>\n<p>DNS 攻击主要是 DDoS 攻击和中间人攻击。</p>\n<p>TCP / UDP 套接字编程，都是要先启动服务端程序，以等待客户端的连接请求。不同的是 TCP 在发起连接之前会有一个三次握手的过程，幸运的是，这个过程对客户和程序是完全透明的，运输层会自己做这件事。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>IP 地址用于标识主机的唯一地址，但 IP 地址对人类是不友好的，难于记忆的，所以就出现了域名。因此需要一个系统可以将 IP 地址和域名进行转换，这就是域名系统（DNS）。</p>\n<p><strong>DNS 协议属于应用层协议，运行在 UDP 之上，使用 53 号端口。</strong></p>\n<p>除了域名和 IP 地址这间的转换服务外，DNS 还提供一下服务：</p>\n<ul>\n<li>主机别名</li>\n<li>邮件服务器别名</li>\n<li>负载分配</li>\n</ul>\n<p>单一 DNS 服务器上运行集中式数据库完全没有任何扩展能力，有以下弊端。</p>\n<ul>\n<li>单点故障：该服务器崩溃，整个因特网将瘫痪</li>\n<li>通信容量：处理所有 DNS 查询</li>\n<li>远距离的集中式数据库：有可能查询一次要绕半个地球</li>\n<li>维护：添加新的记录时要频繁更新。</li>\n</ul>\n<p>因此，DNS 服务器采取分布式分层次数据库来对外提供服务，共分为根 DNS 服务器，顶级域 DNS 服务器，权威 DNS 服务器。</p>\n<p>DNS 数据库中的记录插入由<strong>注册登记机构</strong>负责。</p>\n<p>DNS 攻击主要是 DDoS 攻击和中间人攻击。</p>\n<p>TCP / UDP 套接字编程，都是要先启动服务端程序，以等待客户端的连接请求。不同的是 TCP 在发起连接之前会有一个三次握手的过程，幸运的是，这个过程对客户和程序是完全透明的，运输层会自己做这件事。</p>\n"},{"title":"计算机网络自顶向下方法读书笔记（第三章之一）","date":"2019-05-21T16:00:00.000Z","catalog":true,"_content":"\n本章节开始讲运输层。\n\n运输层位于应用层和网络层中间，负责将应用程序的数据发送至网络层和从网络层接收数据转交给相应的应用程序。\n\n网络层提供了主机间的逻辑通信，而运输层则为运行在不同主机之上的进程之间提供逻辑通信。\n\n运输层运行的协议主要是 TCP 和 UDP。\n\n### UDP\n\nUDP 是无连接的（发送数据之前双方运输层没有进行握手）不可靠传输的协议。\n\nUDP 只是做了运输协议能够做的最少量的工作，除了多路复用/分解以及少量的差错校验之外，UDP 几乎没有对 IP 增加新的功能。\n\n一个 UDP 套接字由一个二元组来全面标识，该二元组就是目的 IP 地址和目的端口号。因此，如果有两个 UDP 报文段有两个不同的源 IP 地址和/或源端口号，但却具有相同的目的 IP 地址和目的端口号，则两个报文段则通过相同的目的套接字定向到相同的目的进程。\n\n### TCP\n\n而 TCP 是面向连接的，可靠传输的协议。一个 TCP 套接字由一个四元组来标识（源 IP，源端口号，目的 IP，目的端口号）。两个具有不同源 IP 地址或源端口号的到达 TCP 报文段将被定向到两个不同的套接字。\n\n### UDP 优点\n\n虽然 UDP 是无连接的，且 不可靠传输的协议，正因为如此， 许多应用选择了 UDP 协议，比如 DNS。\n\n+ 关于何时，发送什么数据的应用层控制更为精细\n+ 速度快，无需建立连接\n+ 分组首部开销小（TCP 首部有 20 个字节 ，而 UDP 只有 8 个）","source":"_posts/network-03-01.md","raw":"---\ntitle: 计算机网络自顶向下方法读书笔记（第三章之一）\ndate: 2019-05-22\ntags: \n    - network\ncatalog: true\n---\n\n本章节开始讲运输层。\n\n运输层位于应用层和网络层中间，负责将应用程序的数据发送至网络层和从网络层接收数据转交给相应的应用程序。\n\n网络层提供了主机间的逻辑通信，而运输层则为运行在不同主机之上的进程之间提供逻辑通信。\n\n运输层运行的协议主要是 TCP 和 UDP。\n\n### UDP\n\nUDP 是无连接的（发送数据之前双方运输层没有进行握手）不可靠传输的协议。\n\nUDP 只是做了运输协议能够做的最少量的工作，除了多路复用/分解以及少量的差错校验之外，UDP 几乎没有对 IP 增加新的功能。\n\n一个 UDP 套接字由一个二元组来全面标识，该二元组就是目的 IP 地址和目的端口号。因此，如果有两个 UDP 报文段有两个不同的源 IP 地址和/或源端口号，但却具有相同的目的 IP 地址和目的端口号，则两个报文段则通过相同的目的套接字定向到相同的目的进程。\n\n### TCP\n\n而 TCP 是面向连接的，可靠传输的协议。一个 TCP 套接字由一个四元组来标识（源 IP，源端口号，目的 IP，目的端口号）。两个具有不同源 IP 地址或源端口号的到达 TCP 报文段将被定向到两个不同的套接字。\n\n### UDP 优点\n\n虽然 UDP 是无连接的，且 不可靠传输的协议，正因为如此， 许多应用选择了 UDP 协议，比如 DNS。\n\n+ 关于何时，发送什么数据的应用层控制更为精细\n+ 速度快，无需建立连接\n+ 分组首部开销小（TCP 首部有 20 个字节 ，而 UDP 只有 8 个）","slug":"network-03-01","published":1,"updated":"2021-02-04T09:31:29.088Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqurlvj0008rca7ghw6nt2g","content":"<p>本章节开始讲运输层。</p>\n<p>运输层位于应用层和网络层中间，负责将应用程序的数据发送至网络层和从网络层接收数据转交给相应的应用程序。</p>\n<p>网络层提供了主机间的逻辑通信，而运输层则为运行在不同主机之上的进程之间提供逻辑通信。</p>\n<p>运输层运行的协议主要是 TCP 和 UDP。</p>\n<h3 id=\"udp\">UDP</h3>\n<p>UDP 是无连接的（发送数据之前双方运输层没有进行握手）不可靠传输的协议。</p>\n<p>UDP 只是做了运输协议能够做的最少量的工作，除了多路复用/分解以及少量的差错校验之外，UDP 几乎没有对 IP 增加新的功能。</p>\n<p>一个 UDP 套接字由一个二元组来全面标识，该二元组就是目的 IP 地址和目的端口号。因此，如果有两个 UDP 报文段有两个不同的源 IP 地址和/或源端口号，但却具有相同的目的 IP 地址和目的端口号，则两个报文段则通过相同的目的套接字定向到相同的目的进程。</p>\n<h3 id=\"tcp\">TCP</h3>\n<p>而 TCP 是面向连接的，可靠传输的协议。一个 TCP 套接字由一个四元组来标识（源 IP，源端口号，目的 IP，目的端口号）。两个具有不同源 IP 地址或源端口号的到达 TCP 报文段将被定向到两个不同的套接字。</p>\n<h3 id=\"udp-优点\">UDP 优点</h3>\n<p>虽然 UDP 是无连接的，且 不可靠传输的协议，正因为如此， 许多应用选择了 UDP 协议，比如 DNS。</p>\n<ul>\n<li>关于何时，发送什么数据的应用层控制更为精细</li>\n<li>速度快，无需建立连接</li>\n<li>分组首部开销小（TCP 首部有 20 个字节 ，而 UDP 只有 8 个）</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>本章节开始讲运输层。</p>\n<p>运输层位于应用层和网络层中间，负责将应用程序的数据发送至网络层和从网络层接收数据转交给相应的应用程序。</p>\n<p>网络层提供了主机间的逻辑通信，而运输层则为运行在不同主机之上的进程之间提供逻辑通信。</p>\n<p>运输层运行的协议主要是 TCP 和 UDP。</p>\n<h3>UDP</h3>\n<p>UDP 是无连接的（发送数据之前双方运输层没有进行握手）不可靠传输的协议。</p>\n<p>UDP 只是做了运输协议能够做的最少量的工作，除了多路复用/分解以及少量的差错校验之外，UDP 几乎没有对 IP 增加新的功能。</p>\n<p>一个 UDP 套接字由一个二元组来全面标识，该二元组就是目的 IP 地址和目的端口号。因此，如果有两个 UDP 报文段有两个不同的源 IP 地址和/或源端口号，但却具有相同的目的 IP 地址和目的端口号，则两个报文段则通过相同的目的套接字定向到相同的目的进程。</p>\n<h3>TCP</h3>\n<p>而 TCP 是面向连接的，可靠传输的协议。一个 TCP 套接字由一个四元组来标识（源 IP，源端口号，目的 IP，目的端口号）。两个具有不同源 IP 地址或源端口号的到达 TCP 报文段将被定向到两个不同的套接字。</p>\n<h3>UDP 优点</h3>\n<p>虽然 UDP 是无连接的，且 不可靠传输的协议，正因为如此， 许多应用选择了 UDP 协议，比如 DNS。</p>\n<ul>\n<li>关于何时，发送什么数据的应用层控制更为精细</li>\n<li>速度快，无需建立连接</li>\n<li>分组首部开销小（TCP 首部有 20 个字节 ，而 UDP 只有 8 个）</li>\n</ul>\n"},{"title":"计算机网络自顶向下方法读书笔记（第五章之一）","date":"2019-06-11T16:00:00.000Z","catalog":true,"_content":"\n这周看的主要是关于链路层的知识，链路层处于网络层之下，物理层之上。\n\n链路层提供的可能的服务包括：\n\n+ 成帧\n+ 链路接入\n+ 可靠交付\n+ 差错检测和纠正\n\n其中关于差错检测和纠正技术主要有：\n\n+ 奇偶校验\n+ 检验和方法\n+ 循环冗余检测\n\n### 多路访问链接和协议\n\n链路层有两种网络链路，点对点链路和广播链路。\n\n其中点对点链路由链路一端的单个发送方和链路另一端的单个接收方组成，而广播链路可以让多个发送方和接收方都连接到相同的，单一的，共享的广播信道上。在实践中发现，数以百计甚至数以千计个节点都可以通过一个广播信道直接通信。\n\n后面还讲了很多的协议，看的云里雾里，暂且放下。","source":"_posts/network-05-01.md","raw":"---\ntitle: 计算机网络自顶向下方法读书笔记（第五章之一）\ndate: 2019-06-12\ntags: \n    - network\ncatalog: true\n---\n\n这周看的主要是关于链路层的知识，链路层处于网络层之下，物理层之上。\n\n链路层提供的可能的服务包括：\n\n+ 成帧\n+ 链路接入\n+ 可靠交付\n+ 差错检测和纠正\n\n其中关于差错检测和纠正技术主要有：\n\n+ 奇偶校验\n+ 检验和方法\n+ 循环冗余检测\n\n### 多路访问链接和协议\n\n链路层有两种网络链路，点对点链路和广播链路。\n\n其中点对点链路由链路一端的单个发送方和链路另一端的单个接收方组成，而广播链路可以让多个发送方和接收方都连接到相同的，单一的，共享的广播信道上。在实践中发现，数以百计甚至数以千计个节点都可以通过一个广播信道直接通信。\n\n后面还讲了很多的协议，看的云里雾里，暂且放下。","slug":"network-05-01","published":1,"updated":"2021-02-04T09:18:43.131Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqurlvk0009rca7yafw5qei","content":"<p>这周看的主要是关于链路层的知识，链路层处于网络层之下，物理层之上。</p>\n<p>链路层提供的可能的服务包括：</p>\n<ul>\n<li>成帧</li>\n<li>链路接入</li>\n<li>可靠交付</li>\n<li>差错检测和纠正</li>\n</ul>\n<p>其中关于差错检测和纠正技术主要有：</p>\n<ul>\n<li>奇偶校验</li>\n<li>检验和方法</li>\n<li>循环冗余检测</li>\n</ul>\n<h3 id=\"多路访问链接和协议\">多路访问链接和协议</h3>\n<p>链路层有两种网络链路，点对点链路和广播链路。</p>\n<p>其中点对点链路由链路一端的单个发送方和链路另一端的单个接收方组成，而广播链路可以让多个发送方和接收方都连接到相同的，单一的，共享的广播信道上。在实践中发现，数以百计甚至数以千计个节点都可以通过一个广播信道直接通信。</p>\n<p>后面还讲了很多的协议，看的云里雾里，暂且放下。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这周看的主要是关于链路层的知识，链路层处于网络层之下，物理层之上。</p>\n<p>链路层提供的可能的服务包括：</p>\n<ul>\n<li>成帧</li>\n<li>链路接入</li>\n<li>可靠交付</li>\n<li>差错检测和纠正</li>\n</ul>\n<p>其中关于差错检测和纠正技术主要有：</p>\n<ul>\n<li>奇偶校验</li>\n<li>检验和方法</li>\n<li>循环冗余检测</li>\n</ul>\n<h3>多路访问链接和协议</h3>\n<p>链路层有两种网络链路，点对点链路和广播链路。</p>\n<p>其中点对点链路由链路一端的单个发送方和链路另一端的单个接收方组成，而广播链路可以让多个发送方和接收方都连接到相同的，单一的，共享的广播信道上。在实践中发现，数以百计甚至数以千计个节点都可以通过一个广播信道直接通信。</p>\n<p>后面还讲了很多的协议，看的云里雾里，暂且放下。</p>\n"},{"title":"计算机网络自顶向下方法读书笔记（第四章）","date":"2019-06-04T16:00:00.000Z","catalog":true,"_content":"\n这周看的主要是关于网络层的知识。\n\n运输层提供应用程序间的数据传输，是进程到进程的。而网络层提供的数据传输功能是主机到主机间的。网络层要想提供数据传输，必须具备两个重要的功能，转发和路有选择算法。\n\n> 转发：就是路由器拥有将数据从一个输入端口转移到输出端口的功能。\n> 路由选择算法：简单来说就是路由器要知道从哪个输出端口将数据输出，背后实现的逻辑是转发表。\n\n### 网络服务模型\n\n#### 要求\n\n+ 确保交付：服务确保分组将最终到达目的地\n+ 具有时延上界的确保交付\n+ 有序分组交付\n+ 确保最小带宽\n+ 确保最大时延抖动\n+ 安全性\n\n#### 数据传输\n\n+ 提供连接服务的虚电路网络（VC）\n+ 提供无连接服务的数据报网络\n\n### 路由器工作原理\n\n+ 输入端口处理\n+ 交换\n+ 输出端口处理\n+ 排队机制","source":"_posts/network-04.md","raw":"---\ntitle: 计算机网络自顶向下方法读书笔记（第四章）\ndate: 2019-06-05\ntags: \n    - network\ncatalog: true\n---\n\n这周看的主要是关于网络层的知识。\n\n运输层提供应用程序间的数据传输，是进程到进程的。而网络层提供的数据传输功能是主机到主机间的。网络层要想提供数据传输，必须具备两个重要的功能，转发和路有选择算法。\n\n> 转发：就是路由器拥有将数据从一个输入端口转移到输出端口的功能。\n> 路由选择算法：简单来说就是路由器要知道从哪个输出端口将数据输出，背后实现的逻辑是转发表。\n\n### 网络服务模型\n\n#### 要求\n\n+ 确保交付：服务确保分组将最终到达目的地\n+ 具有时延上界的确保交付\n+ 有序分组交付\n+ 确保最小带宽\n+ 确保最大时延抖动\n+ 安全性\n\n#### 数据传输\n\n+ 提供连接服务的虚电路网络（VC）\n+ 提供无连接服务的数据报网络\n\n### 路由器工作原理\n\n+ 输入端口处理\n+ 交换\n+ 输出端口处理\n+ 排队机制","slug":"network-04","published":1,"updated":"2021-02-04T09:31:56.479Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqurlvn000crca7550p5c45","content":"<p>这周看的主要是关于网络层的知识。</p>\n<p>运输层提供应用程序间的数据传输，是进程到进程的。而网络层提供的数据传输功能是主机到主机间的。网络层要想提供数据传输，必须具备两个重要的功能，转发和路有选择算法。</p>\n<blockquote>\n<p>转发：就是路由器拥有将数据从一个输入端口转移到输出端口的功能。<br>\n路由选择算法：简单来说就是路由器要知道从哪个输出端口将数据输出，背后实现的逻辑是转发表。</p>\n</blockquote>\n<h3 id=\"网络服务模型\">网络服务模型</h3>\n<h4 id=\"要求\">要求</h4>\n<ul>\n<li>确保交付：服务确保分组将最终到达目的地</li>\n<li>具有时延上界的确保交付</li>\n<li>有序分组交付</li>\n<li>确保最小带宽</li>\n<li>确保最大时延抖动</li>\n<li>安全性</li>\n</ul>\n<h4 id=\"数据传输\">数据传输</h4>\n<ul>\n<li>提供连接服务的虚电路网络（VC）</li>\n<li>提供无连接服务的数据报网络</li>\n</ul>\n<h3 id=\"路由器工作原理\">路由器工作原理</h3>\n<ul>\n<li>输入端口处理</li>\n<li>交换</li>\n<li>输出端口处理</li>\n<li>排队机制</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>这周看的主要是关于网络层的知识。</p>\n<p>运输层提供应用程序间的数据传输，是进程到进程的。而网络层提供的数据传输功能是主机到主机间的。网络层要想提供数据传输，必须具备两个重要的功能，转发和路有选择算法。</p>\n<blockquote>\n<p>转发：就是路由器拥有将数据从一个输入端口转移到输出端口的功能。<br>\n路由选择算法：简单来说就是路由器要知道从哪个输出端口将数据输出，背后实现的逻辑是转发表。</p>\n</blockquote>\n<h3>网络服务模型</h3>\n<h4>要求</h4>\n<ul>\n<li>确保交付：服务确保分组将最终到达目的地</li>\n<li>具有时延上界的确保交付</li>\n<li>有序分组交付</li>\n<li>确保最小带宽</li>\n<li>确保最大时延抖动</li>\n<li>安全性</li>\n</ul>\n<h4>数据传输</h4>\n<ul>\n<li>提供连接服务的虚电路网络（VC）</li>\n<li>提供无连接服务的数据报网络</li>\n</ul>\n<h3>路由器工作原理</h3>\n<ul>\n<li>输入端口处理</li>\n<li>交换</li>\n<li>输出端口处理</li>\n<li>排队机制</li>\n</ul>\n"},{"title":"计算机网络自顶向下方法读书笔记（第五章之二）","date":"2019-06-18T16:00:00.000Z","catalog":true,"_content":"\n这周看的主要是关于链路层的知识，链路层处于网络层之下，物理层之上。\n\n### 链路层寻址和 ARP\n\n网络接口都有链路层地址（MAC 地址），所以路由器和交换机以及网卡都有自己特有的 MAC 地址，该地址不因主机的物理位置变化而变化。并且这个地址是全球唯一的，没有重复的。\n\n**目前已经学到的地址包括：应用层的主机名，网络层的 IP 地址以及链路层的 MAC 地址。**\n\n链路层做的事是将网络层提供的数据包封装进自己的帧中，然后加上 MAC 地址等信息之后把帧发送出去，也就是说发送方不仅要知道接收方的 IP 地址（网络层需要），还需要清楚接收方的 MAC 地址（链路层需要）。这两个地址间的转换就是通过 ARP 协议来搞定的。其实就是主机或者路由器维护一个 ARP 表，将 IP 地址和 MAC 地址一一对应起来，每条记录都有一个过期时间，如果在该表中没有要查的 IP 的记录， 则进行 ARP 广播。\n\n**查询 ARP 报文在广播帧中发送，而响应 ARP 报文在一个标准应答中发送。因为 ARP 报文既包含链路层地址，同时也包含网络层地址，所以可以把 ARP 协议堪称是跨越链路层和网络层的协议。**\n\n交换机不仅是无碰撞的，也是名副其实的存储转发分组交换了。在第二层工作，而路由器在第三层工作。其内部维护着一个**交换机表**，分组转发基于 MAC 地址，而不是 IP 地址。\n\n> 交换机毒化：攻击方向交换机发大量的具有不同的源 MAC 地址的分组，用伪造项快速占满交换机表，之后合法的请求就没有了可用的空间，然后该交换机就会广播大多数帧，攻击者就可以用工具来嗅探这些被广播的帧。\n\n以太网帧承载了网络层的 IP 数据报，最大传输单元为 1500 个字节。\n\n### Web 页面的请求历程\n\nBob 启动他的主机，首先运行的协议就是 DHCP 来为自己求得一个 IP 地址。因为没有 IP 地址是发不出去数据的。\n\n然后 Bob 在地址栏输入域名是，操作系统会自动生成一个 DNS 查询，以求得域名对应的 IP 地址。\n\n各项准备工作都做好了，终于可以发起总攻了，下面就是比较熟悉的流程了，TCP 套接字，三次握手后客户端和服务器建立连接，然后就可以正常通信了。","source":"_posts/network-05-02.md","raw":"---\ntitle: 计算机网络自顶向下方法读书笔记（第五章之二）\ndate: 2019-06-19\ntags: \n    - network\ncatalog: true\n---\n\n这周看的主要是关于链路层的知识，链路层处于网络层之下，物理层之上。\n\n### 链路层寻址和 ARP\n\n网络接口都有链路层地址（MAC 地址），所以路由器和交换机以及网卡都有自己特有的 MAC 地址，该地址不因主机的物理位置变化而变化。并且这个地址是全球唯一的，没有重复的。\n\n**目前已经学到的地址包括：应用层的主机名，网络层的 IP 地址以及链路层的 MAC 地址。**\n\n链路层做的事是将网络层提供的数据包封装进自己的帧中，然后加上 MAC 地址等信息之后把帧发送出去，也就是说发送方不仅要知道接收方的 IP 地址（网络层需要），还需要清楚接收方的 MAC 地址（链路层需要）。这两个地址间的转换就是通过 ARP 协议来搞定的。其实就是主机或者路由器维护一个 ARP 表，将 IP 地址和 MAC 地址一一对应起来，每条记录都有一个过期时间，如果在该表中没有要查的 IP 的记录， 则进行 ARP 广播。\n\n**查询 ARP 报文在广播帧中发送，而响应 ARP 报文在一个标准应答中发送。因为 ARP 报文既包含链路层地址，同时也包含网络层地址，所以可以把 ARP 协议堪称是跨越链路层和网络层的协议。**\n\n交换机不仅是无碰撞的，也是名副其实的存储转发分组交换了。在第二层工作，而路由器在第三层工作。其内部维护着一个**交换机表**，分组转发基于 MAC 地址，而不是 IP 地址。\n\n> 交换机毒化：攻击方向交换机发大量的具有不同的源 MAC 地址的分组，用伪造项快速占满交换机表，之后合法的请求就没有了可用的空间，然后该交换机就会广播大多数帧，攻击者就可以用工具来嗅探这些被广播的帧。\n\n以太网帧承载了网络层的 IP 数据报，最大传输单元为 1500 个字节。\n\n### Web 页面的请求历程\n\nBob 启动他的主机，首先运行的协议就是 DHCP 来为自己求得一个 IP 地址。因为没有 IP 地址是发不出去数据的。\n\n然后 Bob 在地址栏输入域名是，操作系统会自动生成一个 DNS 查询，以求得域名对应的 IP 地址。\n\n各项准备工作都做好了，终于可以发起总攻了，下面就是比较熟悉的流程了，TCP 套接字，三次握手后客户端和服务器建立连接，然后就可以正常通信了。","slug":"network-05-02","published":1,"updated":"2021-02-04T09:19:08.153Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqurlvs000erca7o6noiunl","content":"<p>这周看的主要是关于链路层的知识，链路层处于网络层之下，物理层之上。</p>\n<h3 id=\"链路层寻址和-arp\">链路层寻址和 ARP</h3>\n<p>网络接口都有链路层地址（MAC 地址），所以路由器和交换机以及网卡都有自己特有的 MAC 地址，该地址不因主机的物理位置变化而变化。并且这个地址是全球唯一的，没有重复的。</p>\n<p><strong>目前已经学到的地址包括：应用层的主机名，网络层的 IP 地址以及链路层的 MAC 地址。</strong></p>\n<p>链路层做的事是将网络层提供的数据包封装进自己的帧中，然后加上 MAC 地址等信息之后把帧发送出去，也就是说发送方不仅要知道接收方的 IP 地址（网络层需要），还需要清楚接收方的 MAC 地址（链路层需要）。这两个地址间的转换就是通过 ARP 协议来搞定的。其实就是主机或者路由器维护一个 ARP 表，将 IP 地址和 MAC 地址一一对应起来，每条记录都有一个过期时间，如果在该表中没有要查的 IP 的记录， 则进行 ARP 广播。</p>\n<p><strong>查询 ARP 报文在广播帧中发送，而响应 ARP 报文在一个标准应答中发送。因为 ARP 报文既包含链路层地址，同时也包含网络层地址，所以可以把 ARP 协议堪称是跨越链路层和网络层的协议。</strong></p>\n<p>交换机不仅是无碰撞的，也是名副其实的存储转发分组交换了。在第二层工作，而路由器在第三层工作。其内部维护着一个<strong>交换机表</strong>，分组转发基于 MAC 地址，而不是 IP 地址。</p>\n<blockquote>\n<p>交换机毒化：攻击方向交换机发大量的具有不同的源 MAC 地址的分组，用伪造项快速占满交换机表，之后合法的请求就没有了可用的空间，然后该交换机就会广播大多数帧，攻击者就可以用工具来嗅探这些被广播的帧。</p>\n</blockquote>\n<p>以太网帧承载了网络层的 IP 数据报，最大传输单元为 1500 个字节。</p>\n<h3 id=\"web-页面的请求历程\">Web 页面的请求历程</h3>\n<p>Bob 启动他的主机，首先运行的协议就是 DHCP 来为自己求得一个 IP 地址。因为没有 IP 地址是发不出去数据的。</p>\n<p>然后 Bob 在地址栏输入域名是，操作系统会自动生成一个 DNS 查询，以求得域名对应的 IP 地址。</p>\n<p>各项准备工作都做好了，终于可以发起总攻了，下面就是比较熟悉的流程了，TCP 套接字，三次握手后客户端和服务器建立连接，然后就可以正常通信了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这周看的主要是关于链路层的知识，链路层处于网络层之下，物理层之上。</p>\n<h3>链路层寻址和 ARP</h3>\n<p>网络接口都有链路层地址（MAC 地址），所以路由器和交换机以及网卡都有自己特有的 MAC 地址，该地址不因主机的物理位置变化而变化。并且这个地址是全球唯一的，没有重复的。</p>\n<p><strong>目前已经学到的地址包括：应用层的主机名，网络层的 IP 地址以及链路层的 MAC 地址。</strong></p>\n<p>链路层做的事是将网络层提供的数据包封装进自己的帧中，然后加上 MAC 地址等信息之后把帧发送出去，也就是说发送方不仅要知道接收方的 IP 地址（网络层需要），还需要清楚接收方的 MAC 地址（链路层需要）。这两个地址间的转换就是通过 ARP 协议来搞定的。其实就是主机或者路由器维护一个 ARP 表，将 IP 地址和 MAC 地址一一对应起来，每条记录都有一个过期时间，如果在该表中没有要查的 IP 的记录， 则进行 ARP 广播。</p>\n<p><strong>查询 ARP 报文在广播帧中发送，而响应 ARP 报文在一个标准应答中发送。因为 ARP 报文既包含链路层地址，同时也包含网络层地址，所以可以把 ARP 协议堪称是跨越链路层和网络层的协议。</strong></p>\n<p>交换机不仅是无碰撞的，也是名副其实的存储转发分组交换了。在第二层工作，而路由器在第三层工作。其内部维护着一个<strong>交换机表</strong>，分组转发基于 MAC 地址，而不是 IP 地址。</p>\n<blockquote>\n<p>交换机毒化：攻击方向交换机发大量的具有不同的源 MAC 地址的分组，用伪造项快速占满交换机表，之后合法的请求就没有了可用的空间，然后该交换机就会广播大多数帧，攻击者就可以用工具来嗅探这些被广播的帧。</p>\n</blockquote>\n<p>以太网帧承载了网络层的 IP 数据报，最大传输单元为 1500 个字节。</p>\n<h3>Web 页面的请求历程</h3>\n<p>Bob 启动他的主机，首先运行的协议就是 DHCP 来为自己求得一个 IP 地址。因为没有 IP 地址是发不出去数据的。</p>\n<p>然后 Bob 在地址栏输入域名是，操作系统会自动生成一个 DNS 查询，以求得域名对应的 IP 地址。</p>\n<p>各项准备工作都做好了，终于可以发起总攻了，下面就是比较熟悉的流程了，TCP 套接字，三次握手后客户端和服务器建立连接，然后就可以正常通信了。</p>\n"},{"title":"计算机网络自顶向下方法读书笔记（第八章）","date":"2019-06-24T16:00:00.000Z","catalog":true,"_content":"\n前面几章对计算机网络中的各个层做了详细的介绍，本章主要讲的是另外一个大的话题，网络安全。\n\n网络安全具体就是指如何在网络上进行安全的通信，若要达到该目标，则必须具备以下特性：\n\n+ 机密性：近发送方和接收方能够理解传输的报文，加密。\n+ 报文完整性：确保报文在传输过程中不被篡改。\n+ 端点鉴别：发送方和接收方必须能确认对方的身份。\n+ 运行安全性：确保整个局域网的运行安全。\n\n### 密码学\n\n发送方将明文通过加密算法生成密文然后发送出去，接收方收到密文之后，通过解密算法得到明文。所以发送方和接收方都必要知道加密和解密算法才行。但如果这个加密算法被公布出来之后遭到中间人劫持咋办，但是又不可能每两个人之间的通信就自己协商一套加密算法，这成本太高了。\n\n所以比较通用的解决办法就是俩人协商好共用一个秘钥，通过公开的加密算法来加密和解密报文，这样即使遭到中间人劫持，由于中间人没有秘钥也是看不到明文的，这就是对称加密。\n\n但是如果两人相距甚远，怎么在不见面的情况下安全的把秘钥传给对方呢？（下文会说）\n\n### 对称密码加密\n\n#### 凯撒密码\n\n简单来说就是字母推移，将明文字母按照 k 往后推移。比如 k = 3，那么明文”a“将变成密文”d“，明文”b“将变成密文”e“，以此列推。\n\n此方法太过简单，因为最多试 25 次就可以破解出明文了。\n\n#### 单码代替密码\n\n凯撒密码的改进方案，具体做法就是定义一个明文和密文的对照表， 明文中的每个字母都对应一个密文字母，不一定是按顺序往后推移的，可能的配对顺序一下子就提升到了 26!。穷举破解难度增加了不少。\n\n但此方法也有局限，因为明文和密文是一一对应的，但是在典型的英文资料中，每个字母出现的频率是可知的，所以只要截取足够多的密文，就可以很容易破解出明文。\n\n#### 多码代替密码\n\n单码代替密码的改进方案，使用多个单码密码，加密时使用不同的单码密码。比如第一个字母用 C1 加密，第二个字母用 C2 加密，以此类推…\n\n### 非对称密码加密\n\n想想一下，每次通信前，双方都要协商秘钥，也是很烦的一件事。针对这点不足，非对称加密横空出世。\n\n其思想为：每个人都有一对秘钥，称为公钥和私钥，公钥是公开的，全世界都可以知道你的公钥，但私钥只有你本人自己知道。当别人想给你发消息时，用公钥加密，你收到消息之后，用私钥解密即可。因为私钥只有你自己知道，所以即使消息被劫持，也无法解密，即使是发送者自己也是无法解密的。\n\n安全性是保证了，但同时也引入一个问题。就是全世界的人都知道你的公钥，你怎么确定给你发消息的人的身份呢？而非对称加密不存在这个问题，因为发送方知道共享秘钥的事实就已经向接收方隐含的证实了自己的身份。\n\n另外非对称加密算法的效率较对称加密效率较低，所以当两个人想通信时，可以先用非对称加密算法将秘钥发给对方，之后的通信采用对称加密算法，既解决了身份验证问题，又解决了效率问题。\n\n### 报文完整性\n\n报文完整性是指，接收方在收到报文之后，要确认以下 2 个信息：\n\n+ 报文确实源自发送方\n+ 报文在传输途中没有被篡改\n\n但是上文不是说了采用非对称密码加密 + 对称加密传输时解决了确认发送方身份的问题吗。是的没错，但是有一个前提，就是你所使用的公钥真的是发送发的公钥，而不是其他人（中间人劫持）的公钥。所以如何让公钥具有可信度是一个大的前提。\n\n再来说说报文篡改，如果中间人改了你们的密文，接收方知道吗？很显然加密算法只保证了报文的机密性，而保证不了完整性。\n\n#### 密码散列函数\n\n找到任意两个不同的报文 x 和 y 使得 H(x) = H(y) 在理论和计算上是不可能的，这就是散列函数。\n\n所以发送方可以发送(m, H(m)) 报文，接收方接收到报文(m, h)，如果 H(m) = h 则说明报文未被更篡改过。\n\n但是仍可能遭到中间人攻击，因为算法是公开的，所以中间人可以生成 (m’, H(m’))，接收方收到报文后仍能通过验证。\n\n所以为了报文的完整性，仍需增加一个秘钥，称为鉴别秘钥。假设为 s。\n\n则：发送方发送(m + s, H(m + s)) 报文，接收方接收到报文(m, h)，如果 H(m + s) = h 则说明报文未被更篡改过。由于中间人不知道 s，所以当他以同样的方式发送报文时，接收方会验签失败。\n\n#### 数字签名\n\n数字签名同样可以解决报文完整性问题。\n\n发送方用自己的私钥加密报文 K-(m)，验签时只需要将发送方的公钥作用于其数字签名 K+( K-(m))，由此得到 m。\n\n因为是谁签名该报文或文档，都必须在计算签名 K-(m) 过程中使用 K- 这个私钥使得 K+( K-(m)) = m。而知道 K-这个私钥的人只有发送方自己。\n\n所以数字签名确保报文完整性的同时，还可以确认报文的源头。\n\n但是其效率较低。\n\n#### 公钥认证\n\n将公钥和特定实体绑定通常是由认证中心（CA）来做的。\n\nCA 证实一个人，一台机器的真实身份。至于如何认证，则没有强制要求，反正就是无条件信任 CA。\n\n一旦 CA 验证了某个实体的身份，则会生成一个把实体身份和其公钥绑定起来的证书。","source":"_posts/network-08.md","raw":"---\ntitle: 计算机网络自顶向下方法读书笔记（第八章）\ndate: 2019-06-25\ntags: \n    - network\ncatalog: true\n---\n\n前面几章对计算机网络中的各个层做了详细的介绍，本章主要讲的是另外一个大的话题，网络安全。\n\n网络安全具体就是指如何在网络上进行安全的通信，若要达到该目标，则必须具备以下特性：\n\n+ 机密性：近发送方和接收方能够理解传输的报文，加密。\n+ 报文完整性：确保报文在传输过程中不被篡改。\n+ 端点鉴别：发送方和接收方必须能确认对方的身份。\n+ 运行安全性：确保整个局域网的运行安全。\n\n### 密码学\n\n发送方将明文通过加密算法生成密文然后发送出去，接收方收到密文之后，通过解密算法得到明文。所以发送方和接收方都必要知道加密和解密算法才行。但如果这个加密算法被公布出来之后遭到中间人劫持咋办，但是又不可能每两个人之间的通信就自己协商一套加密算法，这成本太高了。\n\n所以比较通用的解决办法就是俩人协商好共用一个秘钥，通过公开的加密算法来加密和解密报文，这样即使遭到中间人劫持，由于中间人没有秘钥也是看不到明文的，这就是对称加密。\n\n但是如果两人相距甚远，怎么在不见面的情况下安全的把秘钥传给对方呢？（下文会说）\n\n### 对称密码加密\n\n#### 凯撒密码\n\n简单来说就是字母推移，将明文字母按照 k 往后推移。比如 k = 3，那么明文”a“将变成密文”d“，明文”b“将变成密文”e“，以此列推。\n\n此方法太过简单，因为最多试 25 次就可以破解出明文了。\n\n#### 单码代替密码\n\n凯撒密码的改进方案，具体做法就是定义一个明文和密文的对照表， 明文中的每个字母都对应一个密文字母，不一定是按顺序往后推移的，可能的配对顺序一下子就提升到了 26!。穷举破解难度增加了不少。\n\n但此方法也有局限，因为明文和密文是一一对应的，但是在典型的英文资料中，每个字母出现的频率是可知的，所以只要截取足够多的密文，就可以很容易破解出明文。\n\n#### 多码代替密码\n\n单码代替密码的改进方案，使用多个单码密码，加密时使用不同的单码密码。比如第一个字母用 C1 加密，第二个字母用 C2 加密，以此类推…\n\n### 非对称密码加密\n\n想想一下，每次通信前，双方都要协商秘钥，也是很烦的一件事。针对这点不足，非对称加密横空出世。\n\n其思想为：每个人都有一对秘钥，称为公钥和私钥，公钥是公开的，全世界都可以知道你的公钥，但私钥只有你本人自己知道。当别人想给你发消息时，用公钥加密，你收到消息之后，用私钥解密即可。因为私钥只有你自己知道，所以即使消息被劫持，也无法解密，即使是发送者自己也是无法解密的。\n\n安全性是保证了，但同时也引入一个问题。就是全世界的人都知道你的公钥，你怎么确定给你发消息的人的身份呢？而非对称加密不存在这个问题，因为发送方知道共享秘钥的事实就已经向接收方隐含的证实了自己的身份。\n\n另外非对称加密算法的效率较对称加密效率较低，所以当两个人想通信时，可以先用非对称加密算法将秘钥发给对方，之后的通信采用对称加密算法，既解决了身份验证问题，又解决了效率问题。\n\n### 报文完整性\n\n报文完整性是指，接收方在收到报文之后，要确认以下 2 个信息：\n\n+ 报文确实源自发送方\n+ 报文在传输途中没有被篡改\n\n但是上文不是说了采用非对称密码加密 + 对称加密传输时解决了确认发送方身份的问题吗。是的没错，但是有一个前提，就是你所使用的公钥真的是发送发的公钥，而不是其他人（中间人劫持）的公钥。所以如何让公钥具有可信度是一个大的前提。\n\n再来说说报文篡改，如果中间人改了你们的密文，接收方知道吗？很显然加密算法只保证了报文的机密性，而保证不了完整性。\n\n#### 密码散列函数\n\n找到任意两个不同的报文 x 和 y 使得 H(x) = H(y) 在理论和计算上是不可能的，这就是散列函数。\n\n所以发送方可以发送(m, H(m)) 报文，接收方接收到报文(m, h)，如果 H(m) = h 则说明报文未被更篡改过。\n\n但是仍可能遭到中间人攻击，因为算法是公开的，所以中间人可以生成 (m’, H(m’))，接收方收到报文后仍能通过验证。\n\n所以为了报文的完整性，仍需增加一个秘钥，称为鉴别秘钥。假设为 s。\n\n则：发送方发送(m + s, H(m + s)) 报文，接收方接收到报文(m, h)，如果 H(m + s) = h 则说明报文未被更篡改过。由于中间人不知道 s，所以当他以同样的方式发送报文时，接收方会验签失败。\n\n#### 数字签名\n\n数字签名同样可以解决报文完整性问题。\n\n发送方用自己的私钥加密报文 K-(m)，验签时只需要将发送方的公钥作用于其数字签名 K+( K-(m))，由此得到 m。\n\n因为是谁签名该报文或文档，都必须在计算签名 K-(m) 过程中使用 K- 这个私钥使得 K+( K-(m)) = m。而知道 K-这个私钥的人只有发送方自己。\n\n所以数字签名确保报文完整性的同时，还可以确认报文的源头。\n\n但是其效率较低。\n\n#### 公钥认证\n\n将公钥和特定实体绑定通常是由认证中心（CA）来做的。\n\nCA 证实一个人，一台机器的真实身份。至于如何认证，则没有强制要求，反正就是无条件信任 CA。\n\n一旦 CA 验证了某个实体的身份，则会生成一个把实体身份和其公钥绑定起来的证书。","slug":"network-08","published":1,"updated":"2021-02-04T09:19:21.788Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqurlvu000hrca7ayzk95zc","content":"<p>前面几章对计算机网络中的各个层做了详细的介绍，本章主要讲的是另外一个大的话题，网络安全。</p>\n<p>网络安全具体就是指如何在网络上进行安全的通信，若要达到该目标，则必须具备以下特性：</p>\n<ul>\n<li>机密性：近发送方和接收方能够理解传输的报文，加密。</li>\n<li>报文完整性：确保报文在传输过程中不被篡改。</li>\n<li>端点鉴别：发送方和接收方必须能确认对方的身份。</li>\n<li>运行安全性：确保整个局域网的运行安全。</li>\n</ul>\n<h3 id=\"密码学\">密码学</h3>\n<p>发送方将明文通过加密算法生成密文然后发送出去，接收方收到密文之后，通过解密算法得到明文。所以发送方和接收方都必要知道加密和解密算法才行。但如果这个加密算法被公布出来之后遭到中间人劫持咋办，但是又不可能每两个人之间的通信就自己协商一套加密算法，这成本太高了。</p>\n<p>所以比较通用的解决办法就是俩人协商好共用一个秘钥，通过公开的加密算法来加密和解密报文，这样即使遭到中间人劫持，由于中间人没有秘钥也是看不到明文的，这就是对称加密。</p>\n<p>但是如果两人相距甚远，怎么在不见面的情况下安全的把秘钥传给对方呢？（下文会说）</p>\n<h3 id=\"对称密码加密\">对称密码加密</h3>\n<h4 id=\"凯撒密码\">凯撒密码</h4>\n<p>简单来说就是字母推移，将明文字母按照 k 往后推移。比如 k = 3，那么明文”a“将变成密文”d“，明文”b“将变成密文”e“，以此列推。</p>\n<p>此方法太过简单，因为最多试 25 次就可以破解出明文了。</p>\n<h4 id=\"单码代替密码\">单码代替密码</h4>\n<p>凯撒密码的改进方案，具体做法就是定义一个明文和密文的对照表， 明文中的每个字母都对应一个密文字母，不一定是按顺序往后推移的，可能的配对顺序一下子就提升到了 26!。穷举破解难度增加了不少。</p>\n<p>但此方法也有局限，因为明文和密文是一一对应的，但是在典型的英文资料中，每个字母出现的频率是可知的，所以只要截取足够多的密文，就可以很容易破解出明文。</p>\n<h4 id=\"多码代替密码\">多码代替密码</h4>\n<p>单码代替密码的改进方案，使用多个单码密码，加密时使用不同的单码密码。比如第一个字母用 C1 加密，第二个字母用 C2 加密，以此类推…</p>\n<h3 id=\"非对称密码加密\">非对称密码加密</h3>\n<p>想想一下，每次通信前，双方都要协商秘钥，也是很烦的一件事。针对这点不足，非对称加密横空出世。</p>\n<p>其思想为：每个人都有一对秘钥，称为公钥和私钥，公钥是公开的，全世界都可以知道你的公钥，但私钥只有你本人自己知道。当别人想给你发消息时，用公钥加密，你收到消息之后，用私钥解密即可。因为私钥只有你自己知道，所以即使消息被劫持，也无法解密，即使是发送者自己也是无法解密的。</p>\n<p>安全性是保证了，但同时也引入一个问题。就是全世界的人都知道你的公钥，你怎么确定给你发消息的人的身份呢？而非对称加密不存在这个问题，因为发送方知道共享秘钥的事实就已经向接收方隐含的证实了自己的身份。</p>\n<p>另外非对称加密算法的效率较对称加密效率较低，所以当两个人想通信时，可以先用非对称加密算法将秘钥发给对方，之后的通信采用对称加密算法，既解决了身份验证问题，又解决了效率问题。</p>\n<h3 id=\"报文完整性\">报文完整性</h3>\n<p>报文完整性是指，接收方在收到报文之后，要确认以下 2 个信息：</p>\n<ul>\n<li>报文确实源自发送方</li>\n<li>报文在传输途中没有被篡改</li>\n</ul>\n<p>但是上文不是说了采用非对称密码加密 + 对称加密传输时解决了确认发送方身份的问题吗。是的没错，但是有一个前提，就是你所使用的公钥真的是发送发的公钥，而不是其他人（中间人劫持）的公钥。所以如何让公钥具有可信度是一个大的前提。</p>\n<p>再来说说报文篡改，如果中间人改了你们的密文，接收方知道吗？很显然加密算法只保证了报文的机密性，而保证不了完整性。</p>\n<h4 id=\"密码散列函数\">密码散列函数</h4>\n<p>找到任意两个不同的报文 x 和 y 使得 H(x) = H(y) 在理论和计算上是不可能的，这就是散列函数。</p>\n<p>所以发送方可以发送(m, H(m)) 报文，接收方接收到报文(m, h)，如果 H(m) = h 则说明报文未被更篡改过。</p>\n<p>但是仍可能遭到中间人攻击，因为算法是公开的，所以中间人可以生成 (m’, H(m’))，接收方收到报文后仍能通过验证。</p>\n<p>所以为了报文的完整性，仍需增加一个秘钥，称为鉴别秘钥。假设为 s。</p>\n<p>则：发送方发送(m + s, H(m + s)) 报文，接收方接收到报文(m, h)，如果 H(m + s) = h 则说明报文未被更篡改过。由于中间人不知道 s，所以当他以同样的方式发送报文时，接收方会验签失败。</p>\n<h4 id=\"数字签名\">数字签名</h4>\n<p>数字签名同样可以解决报文完整性问题。</p>\n<p>发送方用自己的私钥加密报文 K-(m)，验签时只需要将发送方的公钥作用于其数字签名 K+( K-(m))，由此得到 m。</p>\n<p>因为是谁签名该报文或文档，都必须在计算签名 K-(m) 过程中使用 K- 这个私钥使得 K+( K-(m)) = m。而知道 K-这个私钥的人只有发送方自己。</p>\n<p>所以数字签名确保报文完整性的同时，还可以确认报文的源头。</p>\n<p>但是其效率较低。</p>\n<h4 id=\"公钥认证\">公钥认证</h4>\n<p>将公钥和特定实体绑定通常是由认证中心（CA）来做的。</p>\n<p>CA 证实一个人，一台机器的真实身份。至于如何认证，则没有强制要求，反正就是无条件信任 CA。</p>\n<p>一旦 CA 验证了某个实体的身份，则会生成一个把实体身份和其公钥绑定起来的证书。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>前面几章对计算机网络中的各个层做了详细的介绍，本章主要讲的是另外一个大的话题，网络安全。</p>\n<p>网络安全具体就是指如何在网络上进行安全的通信，若要达到该目标，则必须具备以下特性：</p>\n<ul>\n<li>机密性：近发送方和接收方能够理解传输的报文，加密。</li>\n<li>报文完整性：确保报文在传输过程中不被篡改。</li>\n<li>端点鉴别：发送方和接收方必须能确认对方的身份。</li>\n<li>运行安全性：确保整个局域网的运行安全。</li>\n</ul>\n<h3>密码学</h3>\n<p>发送方将明文通过加密算法生成密文然后发送出去，接收方收到密文之后，通过解密算法得到明文。所以发送方和接收方都必要知道加密和解密算法才行。但如果这个加密算法被公布出来之后遭到中间人劫持咋办，但是又不可能每两个人之间的通信就自己协商一套加密算法，这成本太高了。</p>\n<p>所以比较通用的解决办法就是俩人协商好共用一个秘钥，通过公开的加密算法来加密和解密报文，这样即使遭到中间人劫持，由于中间人没有秘钥也是看不到明文的，这就是对称加密。</p>\n<p>但是如果两人相距甚远，怎么在不见面的情况下安全的把秘钥传给对方呢？（下文会说）</p>\n<h3>对称密码加密</h3>\n<h4>凯撒密码</h4>\n<p>简单来说就是字母推移，将明文字母按照 k 往后推移。比如 k = 3，那么明文”a“将变成密文”d“，明文”b“将变成密文”e“，以此列推。</p>\n<p>此方法太过简单，因为最多试 25 次就可以破解出明文了。</p>\n<h4>单码代替密码</h4>\n<p>凯撒密码的改进方案，具体做法就是定义一个明文和密文的对照表， 明文中的每个字母都对应一个密文字母，不一定是按顺序往后推移的，可能的配对顺序一下子就提升到了 26!。穷举破解难度增加了不少。</p>\n<p>但此方法也有局限，因为明文和密文是一一对应的，但是在典型的英文资料中，每个字母出现的频率是可知的，所以只要截取足够多的密文，就可以很容易破解出明文。</p>\n<h4>多码代替密码</h4>\n<p>单码代替密码的改进方案，使用多个单码密码，加密时使用不同的单码密码。比如第一个字母用 C1 加密，第二个字母用 C2 加密，以此类推…</p>\n<h3>非对称密码加密</h3>\n<p>想想一下，每次通信前，双方都要协商秘钥，也是很烦的一件事。针对这点不足，非对称加密横空出世。</p>\n<p>其思想为：每个人都有一对秘钥，称为公钥和私钥，公钥是公开的，全世界都可以知道你的公钥，但私钥只有你本人自己知道。当别人想给你发消息时，用公钥加密，你收到消息之后，用私钥解密即可。因为私钥只有你自己知道，所以即使消息被劫持，也无法解密，即使是发送者自己也是无法解密的。</p>\n<p>安全性是保证了，但同时也引入一个问题。就是全世界的人都知道你的公钥，你怎么确定给你发消息的人的身份呢？而非对称加密不存在这个问题，因为发送方知道共享秘钥的事实就已经向接收方隐含的证实了自己的身份。</p>\n<p>另外非对称加密算法的效率较对称加密效率较低，所以当两个人想通信时，可以先用非对称加密算法将秘钥发给对方，之后的通信采用对称加密算法，既解决了身份验证问题，又解决了效率问题。</p>\n<h3>报文完整性</h3>\n<p>报文完整性是指，接收方在收到报文之后，要确认以下 2 个信息：</p>\n<ul>\n<li>报文确实源自发送方</li>\n<li>报文在传输途中没有被篡改</li>\n</ul>\n<p>但是上文不是说了采用非对称密码加密 + 对称加密传输时解决了确认发送方身份的问题吗。是的没错，但是有一个前提，就是你所使用的公钥真的是发送发的公钥，而不是其他人（中间人劫持）的公钥。所以如何让公钥具有可信度是一个大的前提。</p>\n<p>再来说说报文篡改，如果中间人改了你们的密文，接收方知道吗？很显然加密算法只保证了报文的机密性，而保证不了完整性。</p>\n<h4>密码散列函数</h4>\n<p>找到任意两个不同的报文 x 和 y 使得 H(x) = H(y) 在理论和计算上是不可能的，这就是散列函数。</p>\n<p>所以发送方可以发送(m, H(m)) 报文，接收方接收到报文(m, h)，如果 H(m) = h 则说明报文未被更篡改过。</p>\n<p>但是仍可能遭到中间人攻击，因为算法是公开的，所以中间人可以生成 (m’, H(m’))，接收方收到报文后仍能通过验证。</p>\n<p>所以为了报文的完整性，仍需增加一个秘钥，称为鉴别秘钥。假设为 s。</p>\n<p>则：发送方发送(m + s, H(m + s)) 报文，接收方接收到报文(m, h)，如果 H(m + s) = h 则说明报文未被更篡改过。由于中间人不知道 s，所以当他以同样的方式发送报文时，接收方会验签失败。</p>\n<h4>数字签名</h4>\n<p>数字签名同样可以解决报文完整性问题。</p>\n<p>发送方用自己的私钥加密报文 K-(m)，验签时只需要将发送方的公钥作用于其数字签名 K+( K-(m))，由此得到 m。</p>\n<p>因为是谁签名该报文或文档，都必须在计算签名 K-(m) 过程中使用 K- 这个私钥使得 K+( K-(m)) = m。而知道 K-这个私钥的人只有发送方自己。</p>\n<p>所以数字签名确保报文完整性的同时，还可以确认报文的源头。</p>\n<p>但是其效率较低。</p>\n<h4>公钥认证</h4>\n<p>将公钥和特定实体绑定通常是由认证中心（CA）来做的。</p>\n<p>CA 证实一个人，一台机器的真实身份。至于如何认证，则没有强制要求，反正就是无条件信任 CA。</p>\n<p>一旦 CA 验证了某个实体的身份，则会生成一个把实体身份和其公钥绑定起来的证书。</p>\n"},{"title":"计算机网络自顶向下方法读书笔记（第三章之二）","date":"2019-05-28T16:00:00.000Z","catalog":true,"_content":"\n这周看的主要是关于 TCP 的可靠传输，拥塞控制以及流量控制。\n\n![](https://mubu.com/document_image/f551971e-6871-4966-8d7e-f42db646a697-803961.jpg)\n\n### TCP 报文说明\n\n+ Sequence number: 简写为 sep。序号，报文段是以字节来打包的，序号是报文段中第一个字节序号。解决了网络包乱序问题。\n+ Acknowledgment number: 简写为 ack。确认号。期待接受方下一次发送的序号 = [上次发送的序号 + 报文长度]。解决了丢包问题。若确认号 = N，则表明到序号 N - 1 为止的所有数据都已正确收到。\n+ TCP Flags ，也就是包的类型，主要是用于操控 TCP 的状态机的。\n\t- SYN 表示建立连接。\n\t- FIN 表示关闭连接。\n\t- ACK 表示响应。仅当 ACK = 1 时，确认号才有效。TCP 规定，连接建立后所有传送的报文段都必须把 ACK 置 1。\n\n注意：不要把 flag 的 ACK 和 确认号 ack 搞混淆，只有当 ACK = 1 时，ack 才有意义。\n\nTCP 是可靠传输协议，基本上所有特性都是为了可靠传输这个目标来服务的，然后有一些是出于优化性能的目的。\n\n### 特点\n\n#### 三次握手\n\n![](https://mubu.com/document_image/7624f14c-d66b-4e68-b6a8-ab14a8b8669f-803961.jpg)\n\n+ 第一次：client 发送 SYN = 1，且随机产生序号 seq = x 发送至 server。server 由 SYN = 1 知道 client 要建立连接。\n\n+ 第二次：server 收到 SYN 后，回复 SYN = 1，ACK = 1，ack = x + 1。(client 的 seq + 1)，且随机产生自己的序号 seq = y 至 client。\n\n+ 第三次：client 收到 SYN + ACK 后，回复 SYN = 1，ack = y + 1 (server 的 seq + 1)，seq = x + 1 至 server。\n\n**主要目的：**\n\n告知对方 seq 和 ack「收到的 seq+ 报文长度」。这样发送方就知道有没有丢包了。「蓝框是 client 的初始 seq，绿框是 server 的初始 seq」。\n\n**次要目的：**告知和协商一些信息\n\n+ MSS：最大传输包\n+ SACK_PERM：是否支持Selective ack(用户优化重传效率）\n+ WS：窗口计算指数\n\n#### 四次挥手\n\n+ 第一次：client 发送 FIN = 1，seq = u「前面已经传送的数据的最后一个字节的序号 + 1」\n+ 第二次：server 发送 ACK = 1，seq = v 「前面已经传送的数据的最后一个字节的序号 + 1」，ack = u + 1\n+ 第三次：server 发送 FIN = 1，ACK = 1，ack = u + 1，seq = w（在半关闭状态 server 可能又发送了一些数据）\n+ 第四次：client 发送 ACK = 1，ack = w + 1，seq = u + 1。发送完之后等待 2MSL 关闭链接。\n\n#### 可靠链接（确认机制，丢包重传）\n\n停止等待 ARQ 协议 发送方没法送完一个分组就停止发送，直到收到对方的确认才发送下一个分组\n\n+ 超时重传：B 收到包 M1 检查出有问题或者 M1 在传输过程中丢失，在这两种情况下，B 什么都不做。A 过一段时间发现未收到确认，于是就认为包丢失了，故重传。\n\t- 超时计时器。发送完启动，收到确认归零。计时器时长应该大于传输的平均往返时长。\n\t- 保留副本\n+ 确认丢失：即 B 发给 A 的 ack 丢失。A 超时重传，B 收到重复的 M1 时，采取两个动作\n\t- 丢弃掉 M1，不向上层交付\n\t- 回复 ack。不要认为已经发送过就不在发送\n+ 确认迟到：即 B 发给 A 的 ack 迟到了。B 收到重复的 M1 时同意采取上面的两个动作。A 收到迟到的 ack 确认时，直接丢弃。\n+ 使用上述的确认和重传机制就可以实现在不可靠的网络上实现可靠传输。\n+ 连续 ARQ 协议 提高了吞吐量。\n\t- 这个要牵涉到滑动窗口了。发送方一次可以把发送窗口内的分组都发出去，接收方对按序到达的最后一个分组做确认。\n\t- 对于不按序到达的数据如何处理，TCP 并无明确规定，但是大部分都是先临时存放在接收窗口中。\n\t- 选择确认 SACK。在 TCP 的首部选项增加 SACK 选项，保存接收到的字节边界。首部选项 40 个字节 ，一个用来保存 SACK 选项，一个用来指明这个选项占用多少字节。一个边界序号为 32 位，占四个字节，所以最多可以包含八个边界，也就是四个字节块。\n\n\n### 为啥需要三次握手，而不是两次或者四次。\n\n防止已经失效的链接请求报文突然又传到了 server。\n\n已失效的链接是这样产生的。在网络不好的情况下，a 向 b 发出链接请求，把这次链接请求标记为 TCP1，但是因为网络延迟 b 没有收到，于是也就没有确认回复给 a。由于 a 超时未收到 b 的确认，于是 a 重新发送链接请求，把这次链接请求标记为 TCP2，正常收到了 b 的确认，如果是两次握手的话这时候链接就建立起来了，传输完数据正常关闭链接 TCP2。看起来一切都很正常没啥问题，但是不巧的是在 b 链接关闭之后 TCP1 的链接请求又发送到了 b，本来这个链接是失效的，但是 b 会认为这是一个新的链接请求，于是回复确认给 a，如果采用两次握手这时候链接就建立起来了，b 会等待发送数据或主动发送数据，但是 a 已经关闭了啊，浪费服务端资源。所以需要三次，至于为啥不会四次，因为三次是最小值，四次就浪费了。\n\n从另外一个角度来讲就是让双方都证实对方能发收。\n\n1. A发，B收， B知道A能发\n1. B发，A收， A知道B能发收\n1. A发，B收， B知道A能收\n\n### 为啥需要四次挥手\n\n三次握手的第二步发 syn+ack，如果拆分成两步先发 ack 再发 syn 完全也是可以的（效率略低），这样三次握手也变成四次握手了。挥手的时候多一次，主要是收到第一个 FIN 包后单独回复了一个 ACK 包，如果能回复 FIN+ACK 的话，那么四次挥手也就变成三次了。之所以是四次挥手，是因为收到 FIN 后，知道对方要关闭了，然后 OS 通知应用层要关闭资源啥的，这里应用层可能需要做些准备工作，有一些延时，所以先回 ACK，准备好了再发 FIN 。 握手过程没有这个准备过程所以可以立即发送 SYN+ACK。\n\n### 四次握手最后一次握手为什么等待 2MSL ？\n\n保证 client 发出的 ACK 确认能够到达 server。假设 ACK 确认丢失，server收不到确认会重传 FIN + ACK 报文， client 就可以在这段时间内收到并重传 ACK 确认。并重新启动计时器。如果 client 马上关闭，由于 server 收不到确认，所以就无法正常进入 CLOSED 状态。\n\n防止跟三次握手时一样的“已失效的链接请求报文段”\n\nack = seq + len，但是特例是三次握手和四次挥手，虽然 len 都是 0，但是TCP 规定 SYN = 1 和 FIN = 1 的报文段，不可以携带数据 ，但是都要消耗掉一个序列号。ACK 报文段可以携带数据，但是如果不携带则不消耗序列号，所以这里·的 ack 都是 seq + 1。\n\n### 流量控制，控制发送方的发送频率\n\n+ 通过窗口大小来控制\n\n+ 持续计数器。 B 向 A 发送了窗口为零的报文后不久，B 有位置可以存储数据了，于是发送了窗口 = 400 的报文，但是报文丢失了，B 还在傻等 A 发送的数据，A 在等 B 的非零窗口通知。死锁产生了。所以引入持续计数器。只要收到零窗口通知，启动计数器，时间到期就发送一个探测报文，对方确认报文时给出当前的窗口大小，如果还是零，重新设置计数器，如果不是零， 则发送数据，打破死锁局面。\n\n### 拥塞控制\n\n发送方维持一个拥塞窗口的变量，受网络影响是动态变化的，发送放让发送窗口 = 拥塞窗口。考虑接收方处理能力，发送窗口可能小于拥塞窗口。\n\n#### 慢开始\n\n刚开始发送报文时，把拥塞窗口 cwnd 设置为一个最大报文段 MSS 的数值。每收到一个新的确认，把拥塞窗口增加至多一个 MSS 的数值。例如：开始时 cwnd = 1，发送报文段 M1，收到确认后把 cwnd 从 1 增加到 2，发送 M2，M3。收到两个确认后把 cwnd 从 2 增加到 4。每经过一个传输轮次，cwnd 就加倍。\n\n#### 拥塞避免\n\n每经过一个传输轮次 cwnd 不再是加倍，而是直接加 1。\n\n+ 维护一个慢开始门限（ssthresh）的变量，大多数的 TCP 是吸纳来说，ssthresh 的值是 65535。。\n+ 当 cwnd < ssthresh 时，使用慢开始算法。\n+ 当 cwnd > ssthresh 时，改用拥塞避免算法。\n+ 当 cwnd = ssthresh 时，慢开始与拥塞避免算法任意。\n+ 当拥塞发生时（超时收到确认），ssthresh 会被设置为当前窗口大小的一半（ cwnd 和接收方通告窗口大小的最小值，但最少为 2个报文段）。此外 cwnd 会被设置为1个报文段执行慢开始算法。\n\n#### 快重传\n\n发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置重传计时器时间到期。发送 M1, M2, M3。M3 没有收到，又发了 M4, M5, M6 所以会收到对 M2 的三个重复确认。\n\n#### 快恢复\n\n当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 ssthresh 门限减半，但是接下去并不执行慢开始算法；\n\n将 cwnd = ssthresh，直接进入拥塞避免算法。有的快重传会把窗口在增大，考虑到此时能连续收到 3 个ACK，说明网络没有拥塞，执行加法原则，有几个ACK就加几个报文段的字节数。\n\n![](https://mubu.com/document_image/98a47313-45aa-432e-b999-fb01b5e648f0-803961.jpg)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/network-03-02.md","raw":"---\ntitle: 计算机网络自顶向下方法读书笔记（第三章之二）\ndate: 2019-05-29\ntags: \n    - network\ncatalog: true\n---\n\n这周看的主要是关于 TCP 的可靠传输，拥塞控制以及流量控制。\n\n![](https://mubu.com/document_image/f551971e-6871-4966-8d7e-f42db646a697-803961.jpg)\n\n### TCP 报文说明\n\n+ Sequence number: 简写为 sep。序号，报文段是以字节来打包的，序号是报文段中第一个字节序号。解决了网络包乱序问题。\n+ Acknowledgment number: 简写为 ack。确认号。期待接受方下一次发送的序号 = [上次发送的序号 + 报文长度]。解决了丢包问题。若确认号 = N，则表明到序号 N - 1 为止的所有数据都已正确收到。\n+ TCP Flags ，也就是包的类型，主要是用于操控 TCP 的状态机的。\n\t- SYN 表示建立连接。\n\t- FIN 表示关闭连接。\n\t- ACK 表示响应。仅当 ACK = 1 时，确认号才有效。TCP 规定，连接建立后所有传送的报文段都必须把 ACK 置 1。\n\n注意：不要把 flag 的 ACK 和 确认号 ack 搞混淆，只有当 ACK = 1 时，ack 才有意义。\n\nTCP 是可靠传输协议，基本上所有特性都是为了可靠传输这个目标来服务的，然后有一些是出于优化性能的目的。\n\n### 特点\n\n#### 三次握手\n\n![](https://mubu.com/document_image/7624f14c-d66b-4e68-b6a8-ab14a8b8669f-803961.jpg)\n\n+ 第一次：client 发送 SYN = 1，且随机产生序号 seq = x 发送至 server。server 由 SYN = 1 知道 client 要建立连接。\n\n+ 第二次：server 收到 SYN 后，回复 SYN = 1，ACK = 1，ack = x + 1。(client 的 seq + 1)，且随机产生自己的序号 seq = y 至 client。\n\n+ 第三次：client 收到 SYN + ACK 后，回复 SYN = 1，ack = y + 1 (server 的 seq + 1)，seq = x + 1 至 server。\n\n**主要目的：**\n\n告知对方 seq 和 ack「收到的 seq+ 报文长度」。这样发送方就知道有没有丢包了。「蓝框是 client 的初始 seq，绿框是 server 的初始 seq」。\n\n**次要目的：**告知和协商一些信息\n\n+ MSS：最大传输包\n+ SACK_PERM：是否支持Selective ack(用户优化重传效率）\n+ WS：窗口计算指数\n\n#### 四次挥手\n\n+ 第一次：client 发送 FIN = 1，seq = u「前面已经传送的数据的最后一个字节的序号 + 1」\n+ 第二次：server 发送 ACK = 1，seq = v 「前面已经传送的数据的最后一个字节的序号 + 1」，ack = u + 1\n+ 第三次：server 发送 FIN = 1，ACK = 1，ack = u + 1，seq = w（在半关闭状态 server 可能又发送了一些数据）\n+ 第四次：client 发送 ACK = 1，ack = w + 1，seq = u + 1。发送完之后等待 2MSL 关闭链接。\n\n#### 可靠链接（确认机制，丢包重传）\n\n停止等待 ARQ 协议 发送方没法送完一个分组就停止发送，直到收到对方的确认才发送下一个分组\n\n+ 超时重传：B 收到包 M1 检查出有问题或者 M1 在传输过程中丢失，在这两种情况下，B 什么都不做。A 过一段时间发现未收到确认，于是就认为包丢失了，故重传。\n\t- 超时计时器。发送完启动，收到确认归零。计时器时长应该大于传输的平均往返时长。\n\t- 保留副本\n+ 确认丢失：即 B 发给 A 的 ack 丢失。A 超时重传，B 收到重复的 M1 时，采取两个动作\n\t- 丢弃掉 M1，不向上层交付\n\t- 回复 ack。不要认为已经发送过就不在发送\n+ 确认迟到：即 B 发给 A 的 ack 迟到了。B 收到重复的 M1 时同意采取上面的两个动作。A 收到迟到的 ack 确认时，直接丢弃。\n+ 使用上述的确认和重传机制就可以实现在不可靠的网络上实现可靠传输。\n+ 连续 ARQ 协议 提高了吞吐量。\n\t- 这个要牵涉到滑动窗口了。发送方一次可以把发送窗口内的分组都发出去，接收方对按序到达的最后一个分组做确认。\n\t- 对于不按序到达的数据如何处理，TCP 并无明确规定，但是大部分都是先临时存放在接收窗口中。\n\t- 选择确认 SACK。在 TCP 的首部选项增加 SACK 选项，保存接收到的字节边界。首部选项 40 个字节 ，一个用来保存 SACK 选项，一个用来指明这个选项占用多少字节。一个边界序号为 32 位，占四个字节，所以最多可以包含八个边界，也就是四个字节块。\n\n\n### 为啥需要三次握手，而不是两次或者四次。\n\n防止已经失效的链接请求报文突然又传到了 server。\n\n已失效的链接是这样产生的。在网络不好的情况下，a 向 b 发出链接请求，把这次链接请求标记为 TCP1，但是因为网络延迟 b 没有收到，于是也就没有确认回复给 a。由于 a 超时未收到 b 的确认，于是 a 重新发送链接请求，把这次链接请求标记为 TCP2，正常收到了 b 的确认，如果是两次握手的话这时候链接就建立起来了，传输完数据正常关闭链接 TCP2。看起来一切都很正常没啥问题，但是不巧的是在 b 链接关闭之后 TCP1 的链接请求又发送到了 b，本来这个链接是失效的，但是 b 会认为这是一个新的链接请求，于是回复确认给 a，如果采用两次握手这时候链接就建立起来了，b 会等待发送数据或主动发送数据，但是 a 已经关闭了啊，浪费服务端资源。所以需要三次，至于为啥不会四次，因为三次是最小值，四次就浪费了。\n\n从另外一个角度来讲就是让双方都证实对方能发收。\n\n1. A发，B收， B知道A能发\n1. B发，A收， A知道B能发收\n1. A发，B收， B知道A能收\n\n### 为啥需要四次挥手\n\n三次握手的第二步发 syn+ack，如果拆分成两步先发 ack 再发 syn 完全也是可以的（效率略低），这样三次握手也变成四次握手了。挥手的时候多一次，主要是收到第一个 FIN 包后单独回复了一个 ACK 包，如果能回复 FIN+ACK 的话，那么四次挥手也就变成三次了。之所以是四次挥手，是因为收到 FIN 后，知道对方要关闭了，然后 OS 通知应用层要关闭资源啥的，这里应用层可能需要做些准备工作，有一些延时，所以先回 ACK，准备好了再发 FIN 。 握手过程没有这个准备过程所以可以立即发送 SYN+ACK。\n\n### 四次握手最后一次握手为什么等待 2MSL ？\n\n保证 client 发出的 ACK 确认能够到达 server。假设 ACK 确认丢失，server收不到确认会重传 FIN + ACK 报文， client 就可以在这段时间内收到并重传 ACK 确认。并重新启动计时器。如果 client 马上关闭，由于 server 收不到确认，所以就无法正常进入 CLOSED 状态。\n\n防止跟三次握手时一样的“已失效的链接请求报文段”\n\nack = seq + len，但是特例是三次握手和四次挥手，虽然 len 都是 0，但是TCP 规定 SYN = 1 和 FIN = 1 的报文段，不可以携带数据 ，但是都要消耗掉一个序列号。ACK 报文段可以携带数据，但是如果不携带则不消耗序列号，所以这里·的 ack 都是 seq + 1。\n\n### 流量控制，控制发送方的发送频率\n\n+ 通过窗口大小来控制\n\n+ 持续计数器。 B 向 A 发送了窗口为零的报文后不久，B 有位置可以存储数据了，于是发送了窗口 = 400 的报文，但是报文丢失了，B 还在傻等 A 发送的数据，A 在等 B 的非零窗口通知。死锁产生了。所以引入持续计数器。只要收到零窗口通知，启动计数器，时间到期就发送一个探测报文，对方确认报文时给出当前的窗口大小，如果还是零，重新设置计数器，如果不是零， 则发送数据，打破死锁局面。\n\n### 拥塞控制\n\n发送方维持一个拥塞窗口的变量，受网络影响是动态变化的，发送放让发送窗口 = 拥塞窗口。考虑接收方处理能力，发送窗口可能小于拥塞窗口。\n\n#### 慢开始\n\n刚开始发送报文时，把拥塞窗口 cwnd 设置为一个最大报文段 MSS 的数值。每收到一个新的确认，把拥塞窗口增加至多一个 MSS 的数值。例如：开始时 cwnd = 1，发送报文段 M1，收到确认后把 cwnd 从 1 增加到 2，发送 M2，M3。收到两个确认后把 cwnd 从 2 增加到 4。每经过一个传输轮次，cwnd 就加倍。\n\n#### 拥塞避免\n\n每经过一个传输轮次 cwnd 不再是加倍，而是直接加 1。\n\n+ 维护一个慢开始门限（ssthresh）的变量，大多数的 TCP 是吸纳来说，ssthresh 的值是 65535。。\n+ 当 cwnd < ssthresh 时，使用慢开始算法。\n+ 当 cwnd > ssthresh 时，改用拥塞避免算法。\n+ 当 cwnd = ssthresh 时，慢开始与拥塞避免算法任意。\n+ 当拥塞发生时（超时收到确认），ssthresh 会被设置为当前窗口大小的一半（ cwnd 和接收方通告窗口大小的最小值，但最少为 2个报文段）。此外 cwnd 会被设置为1个报文段执行慢开始算法。\n\n#### 快重传\n\n发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置重传计时器时间到期。发送 M1, M2, M3。M3 没有收到，又发了 M4, M5, M6 所以会收到对 M2 的三个重复确认。\n\n#### 快恢复\n\n当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 ssthresh 门限减半，但是接下去并不执行慢开始算法；\n\n将 cwnd = ssthresh，直接进入拥塞避免算法。有的快重传会把窗口在增大，考虑到此时能连续收到 3 个ACK，说明网络没有拥塞，执行加法原则，有几个ACK就加几个报文段的字节数。\n\n![](https://mubu.com/document_image/98a47313-45aa-432e-b999-fb01b5e648f0-803961.jpg)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"network-03-02","published":1,"updated":"2021-02-04T09:18:19.483Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkqurlw0000nrca7qw3n5dlr","content":"<p>这周看的主要是关于 TCP 的可靠传输，拥塞控制以及流量控制。</p>\n<p><img src=\"https://mubu.com/document_image/f551971e-6871-4966-8d7e-f42db646a697-803961.jpg\" alt=\"\"></p>\n<h3 id=\"tcp-报文说明\">TCP 报文说明</h3>\n<ul>\n<li>Sequence number: 简写为 sep。序号，报文段是以字节来打包的，序号是报文段中第一个字节序号。解决了网络包乱序问题。</li>\n<li>Acknowledgment number: 简写为 ack。确认号。期待接受方下一次发送的序号 = [上次发送的序号 + 报文长度]。解决了丢包问题。若确认号 = N，则表明到序号 N - 1 为止的所有数据都已正确收到。</li>\n<li>TCP Flags ，也就是包的类型，主要是用于操控 TCP 的状态机的。\n<ul>\n<li>SYN 表示建立连接。</li>\n<li>FIN 表示关闭连接。</li>\n<li>ACK 表示响应。仅当 ACK = 1 时，确认号才有效。TCP 规定，连接建立后所有传送的报文段都必须把 ACK 置 1。</li>\n</ul>\n</li>\n</ul>\n<p>注意：不要把 flag 的 ACK 和 确认号 ack 搞混淆，只有当 ACK = 1 时，ack 才有意义。</p>\n<p>TCP 是可靠传输协议，基本上所有特性都是为了可靠传输这个目标来服务的，然后有一些是出于优化性能的目的。</p>\n<h3 id=\"特点\">特点</h3>\n<h4 id=\"三次握手\">三次握手</h4>\n<p><img src=\"https://mubu.com/document_image/7624f14c-d66b-4e68-b6a8-ab14a8b8669f-803961.jpg\" alt=\"\"></p>\n<ul>\n<li>\n<p>第一次：client 发送 SYN = 1，且随机产生序号 seq = x 发送至 server。server 由 SYN = 1 知道 client 要建立连接。</p>\n</li>\n<li>\n<p>第二次：server 收到 SYN 后，回复 SYN = 1，ACK = 1，ack = x + 1。(client 的 seq + 1)，且随机产生自己的序号 seq = y 至 client。</p>\n</li>\n<li>\n<p>第三次：client 收到 SYN + ACK 后，回复 SYN = 1，ack = y + 1 (server 的 seq + 1)，seq = x + 1 至 server。</p>\n</li>\n</ul>\n<p><strong>主要目的：</strong></p>\n<p>告知对方 seq 和 ack「收到的 seq+ 报文长度」。这样发送方就知道有没有丢包了。「蓝框是 client 的初始 seq，绿框是 server 的初始 seq」。</p>\n<p>**次要目的：**告知和协商一些信息</p>\n<ul>\n<li>MSS：最大传输包</li>\n<li>SACK_PERM：是否支持Selective ack(用户优化重传效率）</li>\n<li>WS：窗口计算指数</li>\n</ul>\n<h4 id=\"四次挥手\">四次挥手</h4>\n<ul>\n<li>第一次：client 发送 FIN = 1，seq = u「前面已经传送的数据的最后一个字节的序号 + 1」</li>\n<li>第二次：server 发送 ACK = 1，seq = v 「前面已经传送的数据的最后一个字节的序号 + 1」，ack = u + 1</li>\n<li>第三次：server 发送 FIN = 1，ACK = 1，ack = u + 1，seq = w（在半关闭状态 server 可能又发送了一些数据）</li>\n<li>第四次：client 发送 ACK = 1，ack = w + 1，seq = u + 1。发送完之后等待 2MSL 关闭链接。</li>\n</ul>\n<h4 id=\"可靠链接确认机制丢包重传\">可靠链接（确认机制，丢包重传）</h4>\n<p>停止等待 ARQ 协议 发送方没法送完一个分组就停止发送，直到收到对方的确认才发送下一个分组</p>\n<ul>\n<li>超时重传：B 收到包 M1 检查出有问题或者 M1 在传输过程中丢失，在这两种情况下，B 什么都不做。A 过一段时间发现未收到确认，于是就认为包丢失了，故重传。\n<ul>\n<li>超时计时器。发送完启动，收到确认归零。计时器时长应该大于传输的平均往返时长。</li>\n<li>保留副本</li>\n</ul>\n</li>\n<li>确认丢失：即 B 发给 A 的 ack 丢失。A 超时重传，B 收到重复的 M1 时，采取两个动作\n<ul>\n<li>丢弃掉 M1，不向上层交付</li>\n<li>回复 ack。不要认为已经发送过就不在发送</li>\n</ul>\n</li>\n<li>确认迟到：即 B 发给 A 的 ack 迟到了。B 收到重复的 M1 时同意采取上面的两个动作。A 收到迟到的 ack 确认时，直接丢弃。</li>\n<li>使用上述的确认和重传机制就可以实现在不可靠的网络上实现可靠传输。</li>\n<li>连续 ARQ 协议 提高了吞吐量。\n<ul>\n<li>这个要牵涉到滑动窗口了。发送方一次可以把发送窗口内的分组都发出去，接收方对按序到达的最后一个分组做确认。</li>\n<li>对于不按序到达的数据如何处理，TCP 并无明确规定，但是大部分都是先临时存放在接收窗口中。</li>\n<li>选择确认 SACK。在 TCP 的首部选项增加 SACK 选项，保存接收到的字节边界。首部选项 40 个字节 ，一个用来保存 SACK 选项，一个用来指明这个选项占用多少字节。一个边界序号为 32 位，占四个字节，所以最多可以包含八个边界，也就是四个字节块。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"为啥需要三次握手而不是两次或者四次\">为啥需要三次握手，而不是两次或者四次。</h3>\n<p>防止已经失效的链接请求报文突然又传到了 server。</p>\n<p>已失效的链接是这样产生的。在网络不好的情况下，a 向 b 发出链接请求，把这次链接请求标记为 TCP1，但是因为网络延迟 b 没有收到，于是也就没有确认回复给 a。由于 a 超时未收到 b 的确认，于是 a 重新发送链接请求，把这次链接请求标记为 TCP2，正常收到了 b 的确认，如果是两次握手的话这时候链接就建立起来了，传输完数据正常关闭链接 TCP2。看起来一切都很正常没啥问题，但是不巧的是在 b 链接关闭之后 TCP1 的链接请求又发送到了 b，本来这个链接是失效的，但是 b 会认为这是一个新的链接请求，于是回复确认给 a，如果采用两次握手这时候链接就建立起来了，b 会等待发送数据或主动发送数据，但是 a 已经关闭了啊，浪费服务端资源。所以需要三次，至于为啥不会四次，因为三次是最小值，四次就浪费了。</p>\n<p>从另外一个角度来讲就是让双方都证实对方能发收。</p>\n<ol>\n<li>A发，B收， B知道A能发</li>\n<li>B发，A收， A知道B能发收</li>\n<li>A发，B收， B知道A能收</li>\n</ol>\n<h3 id=\"为啥需要四次挥手\">为啥需要四次挥手</h3>\n<p>三次握手的第二步发 syn+ack，如果拆分成两步先发 ack 再发 syn 完全也是可以的（效率略低），这样三次握手也变成四次握手了。挥手的时候多一次，主要是收到第一个 FIN 包后单独回复了一个 ACK 包，如果能回复 FIN+ACK 的话，那么四次挥手也就变成三次了。之所以是四次挥手，是因为收到 FIN 后，知道对方要关闭了，然后 OS 通知应用层要关闭资源啥的，这里应用层可能需要做些准备工作，有一些延时，所以先回 ACK，准备好了再发 FIN 。 握手过程没有这个准备过程所以可以立即发送 SYN+ACK。</p>\n<h3 id=\"四次握手最后一次握手为什么等待-2msl\">四次握手最后一次握手为什么等待 2MSL ？</h3>\n<p>保证 client 发出的 ACK 确认能够到达 server。假设 ACK 确认丢失，server收不到确认会重传 FIN + ACK 报文， client 就可以在这段时间内收到并重传 ACK 确认。并重新启动计时器。如果 client 马上关闭，由于 server 收不到确认，所以就无法正常进入 CLOSED 状态。</p>\n<p>防止跟三次握手时一样的“已失效的链接请求报文段”</p>\n<p>ack = seq + len，但是特例是三次握手和四次挥手，虽然 len 都是 0，但是TCP 规定 SYN = 1 和 FIN = 1 的报文段，不可以携带数据 ，但是都要消耗掉一个序列号。ACK 报文段可以携带数据，但是如果不携带则不消耗序列号，所以这里·的 ack 都是 seq + 1。</p>\n<h3 id=\"流量控制控制发送方的发送频率\">流量控制，控制发送方的发送频率</h3>\n<ul>\n<li>\n<p>通过窗口大小来控制</p>\n</li>\n<li>\n<p>持续计数器。 B 向 A 发送了窗口为零的报文后不久，B 有位置可以存储数据了，于是发送了窗口 = 400 的报文，但是报文丢失了，B 还在傻等 A 发送的数据，A 在等 B 的非零窗口通知。死锁产生了。所以引入持续计数器。只要收到零窗口通知，启动计数器，时间到期就发送一个探测报文，对方确认报文时给出当前的窗口大小，如果还是零，重新设置计数器，如果不是零， 则发送数据，打破死锁局面。</p>\n</li>\n</ul>\n<h3 id=\"拥塞控制\">拥塞控制</h3>\n<p>发送方维持一个拥塞窗口的变量，受网络影响是动态变化的，发送放让发送窗口 = 拥塞窗口。考虑接收方处理能力，发送窗口可能小于拥塞窗口。</p>\n<h4 id=\"慢开始\">慢开始</h4>\n<p>刚开始发送报文时，把拥塞窗口 cwnd 设置为一个最大报文段 MSS 的数值。每收到一个新的确认，把拥塞窗口增加至多一个 MSS 的数值。例如：开始时 cwnd = 1，发送报文段 M1，收到确认后把 cwnd 从 1 增加到 2，发送 M2，M3。收到两个确认后把 cwnd 从 2 增加到 4。每经过一个传输轮次，cwnd 就加倍。</p>\n<h4 id=\"拥塞避免\">拥塞避免</h4>\n<p>每经过一个传输轮次 cwnd 不再是加倍，而是直接加 1。</p>\n<ul>\n<li>维护一个慢开始门限（ssthresh）的变量，大多数的 TCP 是吸纳来说，ssthresh 的值是 65535。。</li>\n<li>当 cwnd &lt; ssthresh 时，使用慢开始算法。</li>\n<li>当 cwnd &gt; ssthresh 时，改用拥塞避免算法。</li>\n<li>当 cwnd = ssthresh 时，慢开始与拥塞避免算法任意。</li>\n<li>当拥塞发生时（超时收到确认），ssthresh 会被设置为当前窗口大小的一半（ cwnd 和接收方通告窗口大小的最小值，但最少为 2个报文段）。此外 cwnd 会被设置为1个报文段执行慢开始算法。</li>\n</ul>\n<h4 id=\"快重传\">快重传</h4>\n<p>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置重传计时器时间到期。发送 M1, M2, M3。M3 没有收到，又发了 M4, M5, M6 所以会收到对 M2 的三个重复确认。</p>\n<h4 id=\"快恢复\">快恢复</h4>\n<p>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 ssthresh 门限减半，但是接下去并不执行慢开始算法；</p>\n<p>将 cwnd = ssthresh，直接进入拥塞避免算法。有的快重传会把窗口在增大，考虑到此时能连续收到 3 个ACK，说明网络没有拥塞，执行加法原则，有几个ACK就加几个报文段的字节数。</p>\n<p><img src=\"https://mubu.com/document_image/98a47313-45aa-432e-b999-fb01b5e648f0-803961.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>这周看的主要是关于 TCP 的可靠传输，拥塞控制以及流量控制。</p>\n<p><img src=\"https://mubu.com/document_image/f551971e-6871-4966-8d7e-f42db646a697-803961.jpg\" alt=\"\"></p>\n<h3>TCP 报文说明</h3>\n<ul>\n<li>Sequence number: 简写为 sep。序号，报文段是以字节来打包的，序号是报文段中第一个字节序号。解决了网络包乱序问题。</li>\n<li>Acknowledgment number: 简写为 ack。确认号。期待接受方下一次发送的序号 = [上次发送的序号 + 报文长度]。解决了丢包问题。若确认号 = N，则表明到序号 N - 1 为止的所有数据都已正确收到。</li>\n<li>TCP Flags ，也就是包的类型，主要是用于操控 TCP 的状态机的。\n<ul>\n<li>SYN 表示建立连接。</li>\n<li>FIN 表示关闭连接。</li>\n<li>ACK 表示响应。仅当 ACK = 1 时，确认号才有效。TCP 规定，连接建立后所有传送的报文段都必须把 ACK 置 1。</li>\n</ul>\n</li>\n</ul>\n<p>注意：不要把 flag 的 ACK 和 确认号 ack 搞混淆，只有当 ACK = 1 时，ack 才有意义。</p>\n<p>TCP 是可靠传输协议，基本上所有特性都是为了可靠传输这个目标来服务的，然后有一些是出于优化性能的目的。</p>\n<h3>特点</h3>\n<h4>三次握手</h4>\n<p><img src=\"https://mubu.com/document_image/7624f14c-d66b-4e68-b6a8-ab14a8b8669f-803961.jpg\" alt=\"\"></p>\n<ul>\n<li>\n<p>第一次：client 发送 SYN = 1，且随机产生序号 seq = x 发送至 server。server 由 SYN = 1 知道 client 要建立连接。</p>\n</li>\n<li>\n<p>第二次：server 收到 SYN 后，回复 SYN = 1，ACK = 1，ack = x + 1。(client 的 seq + 1)，且随机产生自己的序号 seq = y 至 client。</p>\n</li>\n<li>\n<p>第三次：client 收到 SYN + ACK 后，回复 SYN = 1，ack = y + 1 (server 的 seq + 1)，seq = x + 1 至 server。</p>\n</li>\n</ul>\n<p><strong>主要目的：</strong></p>\n<p>告知对方 seq 和 ack「收到的 seq+ 报文长度」。这样发送方就知道有没有丢包了。「蓝框是 client 的初始 seq，绿框是 server 的初始 seq」。</p>\n<p>**次要目的：**告知和协商一些信息</p>\n<ul>\n<li>MSS：最大传输包</li>\n<li>SACK_PERM：是否支持Selective ack(用户优化重传效率）</li>\n<li>WS：窗口计算指数</li>\n</ul>\n<h4>四次挥手</h4>\n<ul>\n<li>第一次：client 发送 FIN = 1，seq = u「前面已经传送的数据的最后一个字节的序号 + 1」</li>\n<li>第二次：server 发送 ACK = 1，seq = v 「前面已经传送的数据的最后一个字节的序号 + 1」，ack = u + 1</li>\n<li>第三次：server 发送 FIN = 1，ACK = 1，ack = u + 1，seq = w（在半关闭状态 server 可能又发送了一些数据）</li>\n<li>第四次：client 发送 ACK = 1，ack = w + 1，seq = u + 1。发送完之后等待 2MSL 关闭链接。</li>\n</ul>\n<h4>可靠链接（确认机制，丢包重传）</h4>\n<p>停止等待 ARQ 协议 发送方没法送完一个分组就停止发送，直到收到对方的确认才发送下一个分组</p>\n<ul>\n<li>超时重传：B 收到包 M1 检查出有问题或者 M1 在传输过程中丢失，在这两种情况下，B 什么都不做。A 过一段时间发现未收到确认，于是就认为包丢失了，故重传。\n<ul>\n<li>超时计时器。发送完启动，收到确认归零。计时器时长应该大于传输的平均往返时长。</li>\n<li>保留副本</li>\n</ul>\n</li>\n<li>确认丢失：即 B 发给 A 的 ack 丢失。A 超时重传，B 收到重复的 M1 时，采取两个动作\n<ul>\n<li>丢弃掉 M1，不向上层交付</li>\n<li>回复 ack。不要认为已经发送过就不在发送</li>\n</ul>\n</li>\n<li>确认迟到：即 B 发给 A 的 ack 迟到了。B 收到重复的 M1 时同意采取上面的两个动作。A 收到迟到的 ack 确认时，直接丢弃。</li>\n<li>使用上述的确认和重传机制就可以实现在不可靠的网络上实现可靠传输。</li>\n<li>连续 ARQ 协议 提高了吞吐量。\n<ul>\n<li>这个要牵涉到滑动窗口了。发送方一次可以把发送窗口内的分组都发出去，接收方对按序到达的最后一个分组做确认。</li>\n<li>对于不按序到达的数据如何处理，TCP 并无明确规定，但是大部分都是先临时存放在接收窗口中。</li>\n<li>选择确认 SACK。在 TCP 的首部选项增加 SACK 选项，保存接收到的字节边界。首部选项 40 个字节 ，一个用来保存 SACK 选项，一个用来指明这个选项占用多少字节。一个边界序号为 32 位，占四个字节，所以最多可以包含八个边界，也就是四个字节块。</li>\n</ul>\n</li>\n</ul>\n<h3>为啥需要三次握手，而不是两次或者四次。</h3>\n<p>防止已经失效的链接请求报文突然又传到了 server。</p>\n<p>已失效的链接是这样产生的。在网络不好的情况下，a 向 b 发出链接请求，把这次链接请求标记为 TCP1，但是因为网络延迟 b 没有收到，于是也就没有确认回复给 a。由于 a 超时未收到 b 的确认，于是 a 重新发送链接请求，把这次链接请求标记为 TCP2，正常收到了 b 的确认，如果是两次握手的话这时候链接就建立起来了，传输完数据正常关闭链接 TCP2。看起来一切都很正常没啥问题，但是不巧的是在 b 链接关闭之后 TCP1 的链接请求又发送到了 b，本来这个链接是失效的，但是 b 会认为这是一个新的链接请求，于是回复确认给 a，如果采用两次握手这时候链接就建立起来了，b 会等待发送数据或主动发送数据，但是 a 已经关闭了啊，浪费服务端资源。所以需要三次，至于为啥不会四次，因为三次是最小值，四次就浪费了。</p>\n<p>从另外一个角度来讲就是让双方都证实对方能发收。</p>\n<ol>\n<li>A发，B收， B知道A能发</li>\n<li>B发，A收， A知道B能发收</li>\n<li>A发，B收， B知道A能收</li>\n</ol>\n<h3>为啥需要四次挥手</h3>\n<p>三次握手的第二步发 syn+ack，如果拆分成两步先发 ack 再发 syn 完全也是可以的（效率略低），这样三次握手也变成四次握手了。挥手的时候多一次，主要是收到第一个 FIN 包后单独回复了一个 ACK 包，如果能回复 FIN+ACK 的话，那么四次挥手也就变成三次了。之所以是四次挥手，是因为收到 FIN 后，知道对方要关闭了，然后 OS 通知应用层要关闭资源啥的，这里应用层可能需要做些准备工作，有一些延时，所以先回 ACK，准备好了再发 FIN 。 握手过程没有这个准备过程所以可以立即发送 SYN+ACK。</p>\n<h3>四次握手最后一次握手为什么等待 2MSL ？</h3>\n<p>保证 client 发出的 ACK 确认能够到达 server。假设 ACK 确认丢失，server收不到确认会重传 FIN + ACK 报文， client 就可以在这段时间内收到并重传 ACK 确认。并重新启动计时器。如果 client 马上关闭，由于 server 收不到确认，所以就无法正常进入 CLOSED 状态。</p>\n<p>防止跟三次握手时一样的“已失效的链接请求报文段”</p>\n<p>ack = seq + len，但是特例是三次握手和四次挥手，虽然 len 都是 0，但是TCP 规定 SYN = 1 和 FIN = 1 的报文段，不可以携带数据 ，但是都要消耗掉一个序列号。ACK 报文段可以携带数据，但是如果不携带则不消耗序列号，所以这里·的 ack 都是 seq + 1。</p>\n<h3>流量控制，控制发送方的发送频率</h3>\n<ul>\n<li>\n<p>通过窗口大小来控制</p>\n</li>\n<li>\n<p>持续计数器。 B 向 A 发送了窗口为零的报文后不久，B 有位置可以存储数据了，于是发送了窗口 = 400 的报文，但是报文丢失了，B 还在傻等 A 发送的数据，A 在等 B 的非零窗口通知。死锁产生了。所以引入持续计数器。只要收到零窗口通知，启动计数器，时间到期就发送一个探测报文，对方确认报文时给出当前的窗口大小，如果还是零，重新设置计数器，如果不是零， 则发送数据，打破死锁局面。</p>\n</li>\n</ul>\n<h3>拥塞控制</h3>\n<p>发送方维持一个拥塞窗口的变量，受网络影响是动态变化的，发送放让发送窗口 = 拥塞窗口。考虑接收方处理能力，发送窗口可能小于拥塞窗口。</p>\n<h4>慢开始</h4>\n<p>刚开始发送报文时，把拥塞窗口 cwnd 设置为一个最大报文段 MSS 的数值。每收到一个新的确认，把拥塞窗口增加至多一个 MSS 的数值。例如：开始时 cwnd = 1，发送报文段 M1，收到确认后把 cwnd 从 1 增加到 2，发送 M2，M3。收到两个确认后把 cwnd 从 2 增加到 4。每经过一个传输轮次，cwnd 就加倍。</p>\n<h4>拥塞避免</h4>\n<p>每经过一个传输轮次 cwnd 不再是加倍，而是直接加 1。</p>\n<ul>\n<li>维护一个慢开始门限（ssthresh）的变量，大多数的 TCP 是吸纳来说，ssthresh 的值是 65535。。</li>\n<li>当 cwnd &lt; ssthresh 时，使用慢开始算法。</li>\n<li>当 cwnd &gt; ssthresh 时，改用拥塞避免算法。</li>\n<li>当 cwnd = ssthresh 时，慢开始与拥塞避免算法任意。</li>\n<li>当拥塞发生时（超时收到确认），ssthresh 会被设置为当前窗口大小的一半（ cwnd 和接收方通告窗口大小的最小值，但最少为 2个报文段）。此外 cwnd 会被设置为1个报文段执行慢开始算法。</li>\n</ul>\n<h4>快重传</h4>\n<p>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置重传计时器时间到期。发送 M1, M2, M3。M3 没有收到，又发了 M4, M5, M6 所以会收到对 M2 的三个重复确认。</p>\n<h4>快恢复</h4>\n<p>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 ssthresh 门限减半，但是接下去并不执行慢开始算法；</p>\n<p>将 cwnd = ssthresh，直接进入拥塞避免算法。有的快重传会把窗口在增大，考虑到此时能连续收到 3 个ACK，说明网络没有拥塞，执行加法原则，有几个ACK就加几个报文段的字节数。</p>\n<p><img src=\"https://mubu.com/document_image/98a47313-45aa-432e-b999-fb01b5e648f0-803961.jpg\" alt=\"\"></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckkqurlvj0008rca7ghw6nt2g","tag_id":"ckkqurlvg0005rca7sndzn926","_id":"ckkqurlvn000brca7didunbv3"},{"post_id":"ckkqurlva0002rca7wrryycz7","tag_id":"ckkqurlvg0005rca7sndzn926","_id":"ckkqurlvr000drca7xhe4dzuw"},{"post_id":"ckkqurlvk0009rca7yafw5qei","tag_id":"ckkqurlvg0005rca7sndzn926","_id":"ckkqurlvu000grca7c0jthgxt"},{"post_id":"ckkqurlvn000crca7550p5c45","tag_id":"ckkqurlvg0005rca7sndzn926","_id":"ckkqurlvv000irca7tz3g4iz5"},{"post_id":"ckkqurlve0004rca76ol33fi2","tag_id":"ckkqurlvg0005rca7sndzn926","_id":"ckkqurlvv000jrca75cpvrya6"},{"post_id":"ckkqurlvs000erca7o6noiunl","tag_id":"ckkqurlvg0005rca7sndzn926","_id":"ckkqurlvv000krca7a9zkj1f0"},{"post_id":"ckkqurlvu000hrca7ayzk95zc","tag_id":"ckkqurlvg0005rca7sndzn926","_id":"ckkqurlvv000lrca7bmrm89kp"},{"post_id":"ckkqurlvi0007rca7pm7grgz3","tag_id":"ckkqurlvg0005rca7sndzn926","_id":"ckkqurlvw000mrca72cu2xb73"},{"post_id":"ckkqurlw0000nrca7qw3n5dlr","tag_id":"ckkqurlvg0005rca7sndzn926","_id":"ckkqurlw1000orca7cclgfydr"}],"Tag":[{"name":"network","_id":"ckkqurlvg0005rca7sndzn926"}]}}