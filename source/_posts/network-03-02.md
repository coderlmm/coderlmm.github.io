---
title: 计算机网络自顶向下方法读书笔记（第三章之二）
date: 2019-05-29
tags: 
    - network
catalog: true
---

这周看的主要是关于 TCP 的可靠传输，拥塞控制以及流量控制。

![](https://mubu.com/document_image/f551971e-6871-4966-8d7e-f42db646a697-803961.jpg)

### TCP 报文说明

+ Sequence number: 简写为 sep。序号，报文段是以字节来打包的，序号是报文段中第一个字节序号。解决了网络包乱序问题。
+ Acknowledgment number: 简写为 ack。确认号。期待接受方下一次发送的序号 = [上次发送的序号 + 报文长度]。解决了丢包问题。若确认号 = N，则表明到序号 N - 1 为止的所有数据都已正确收到。
+ TCP Flags ，也就是包的类型，主要是用于操控 TCP 的状态机的。
	- SYN 表示建立连接。
	- FIN 表示关闭连接。
	- ACK 表示响应。仅当 ACK = 1 时，确认号才有效。TCP 规定，连接建立后所有传送的报文段都必须把 ACK 置 1。

注意：不要把 flag 的 ACK 和 确认号 ack 搞混淆，只有当 ACK = 1 时，ack 才有意义。

TCP 是可靠传输协议，基本上所有特性都是为了可靠传输这个目标来服务的，然后有一些是出于优化性能的目的。

### 特点

#### 三次握手

![](https://mubu.com/document_image/7624f14c-d66b-4e68-b6a8-ab14a8b8669f-803961.jpg)

+ 第一次：client 发送 SYN = 1，且随机产生序号 seq = x 发送至 server。server 由 SYN = 1 知道 client 要建立连接。

+ 第二次：server 收到 SYN 后，回复 SYN = 1，ACK = 1，ack = x + 1。(client 的 seq + 1)，且随机产生自己的序号 seq = y 至 client。

+ 第三次：client 收到 SYN + ACK 后，回复 SYN = 1，ack = y + 1 (server 的 seq + 1)，seq = x + 1 至 server。

**主要目的：**

告知对方 seq 和 ack「收到的 seq+ 报文长度」。这样发送方就知道有没有丢包了。「蓝框是 client 的初始 seq，绿框是 server 的初始 seq」。

**次要目的：**告知和协商一些信息

+ MSS：最大传输包
+ SACK_PERM：是否支持Selective ack(用户优化重传效率）
+ WS：窗口计算指数

#### 四次挥手

+ 第一次：client 发送 FIN = 1，seq = u「前面已经传送的数据的最后一个字节的序号 + 1」
+ 第二次：server 发送 ACK = 1，seq = v 「前面已经传送的数据的最后一个字节的序号 + 1」，ack = u + 1
+ 第三次：server 发送 FIN = 1，ACK = 1，ack = u + 1，seq = w（在半关闭状态 server 可能又发送了一些数据）
+ 第四次：client 发送 ACK = 1，ack = w + 1，seq = u + 1。发送完之后等待 2MSL 关闭链接。

#### 可靠链接（确认机制，丢包重传）

停止等待 ARQ 协议 发送方没法送完一个分组就停止发送，直到收到对方的确认才发送下一个分组

+ 超时重传：B 收到包 M1 检查出有问题或者 M1 在传输过程中丢失，在这两种情况下，B 什么都不做。A 过一段时间发现未收到确认，于是就认为包丢失了，故重传。
	- 超时计时器。发送完启动，收到确认归零。计时器时长应该大于传输的平均往返时长。
	- 保留副本
+ 确认丢失：即 B 发给 A 的 ack 丢失。A 超时重传，B 收到重复的 M1 时，采取两个动作
	- 丢弃掉 M1，不向上层交付
	- 回复 ack。不要认为已经发送过就不在发送
+ 确认迟到：即 B 发给 A 的 ack 迟到了。B 收到重复的 M1 时同意采取上面的两个动作。A 收到迟到的 ack 确认时，直接丢弃。
+ 使用上述的确认和重传机制就可以实现在不可靠的网络上实现可靠传输。
+ 连续 ARQ 协议 提高了吞吐量。
	- 这个要牵涉到滑动窗口了。发送方一次可以把发送窗口内的分组都发出去，接收方对按序到达的最后一个分组做确认。
	- 对于不按序到达的数据如何处理，TCP 并无明确规定，但是大部分都是先临时存放在接收窗口中。
	- 选择确认 SACK。在 TCP 的首部选项增加 SACK 选项，保存接收到的字节边界。首部选项 40 个字节 ，一个用来保存 SACK 选项，一个用来指明这个选项占用多少字节。一个边界序号为 32 位，占四个字节，所以最多可以包含八个边界，也就是四个字节块。


### 为啥需要三次握手，而不是两次或者四次。

防止已经失效的链接请求报文突然又传到了 server。

已失效的链接是这样产生的。在网络不好的情况下，a 向 b 发出链接请求，把这次链接请求标记为 TCP1，但是因为网络延迟 b 没有收到，于是也就没有确认回复给 a。由于 a 超时未收到 b 的确认，于是 a 重新发送链接请求，把这次链接请求标记为 TCP2，正常收到了 b 的确认，如果是两次握手的话这时候链接就建立起来了，传输完数据正常关闭链接 TCP2。看起来一切都很正常没啥问题，但是不巧的是在 b 链接关闭之后 TCP1 的链接请求又发送到了 b，本来这个链接是失效的，但是 b 会认为这是一个新的链接请求，于是回复确认给 a，如果采用两次握手这时候链接就建立起来了，b 会等待发送数据或主动发送数据，但是 a 已经关闭了啊，浪费服务端资源。所以需要三次，至于为啥不会四次，因为三次是最小值，四次就浪费了。

从另外一个角度来讲就是让双方都证实对方能发收。

1. A发，B收， B知道A能发
1. B发，A收， A知道B能发收
1. A发，B收， B知道A能收

### 为啥需要四次挥手

三次握手的第二步发 syn+ack，如果拆分成两步先发 ack 再发 syn 完全也是可以的（效率略低），这样三次握手也变成四次握手了。挥手的时候多一次，主要是收到第一个 FIN 包后单独回复了一个 ACK 包，如果能回复 FIN+ACK 的话，那么四次挥手也就变成三次了。之所以是四次挥手，是因为收到 FIN 后，知道对方要关闭了，然后 OS 通知应用层要关闭资源啥的，这里应用层可能需要做些准备工作，有一些延时，所以先回 ACK，准备好了再发 FIN 。 握手过程没有这个准备过程所以可以立即发送 SYN+ACK。

### 四次握手最后一次握手为什么等待 2MSL ？

保证 client 发出的 ACK 确认能够到达 server。假设 ACK 确认丢失，server收不到确认会重传 FIN + ACK 报文， client 就可以在这段时间内收到并重传 ACK 确认。并重新启动计时器。如果 client 马上关闭，由于 server 收不到确认，所以就无法正常进入 CLOSED 状态。

防止跟三次握手时一样的“已失效的链接请求报文段”

ack = seq + len，但是特例是三次握手和四次挥手，虽然 len 都是 0，但是TCP 规定 SYN = 1 和 FIN = 1 的报文段，不可以携带数据 ，但是都要消耗掉一个序列号。ACK 报文段可以携带数据，但是如果不携带则不消耗序列号，所以这里·的 ack 都是 seq + 1。

### 流量控制，控制发送方的发送频率

+ 通过窗口大小来控制

+ 持续计数器。 B 向 A 发送了窗口为零的报文后不久，B 有位置可以存储数据了，于是发送了窗口 = 400 的报文，但是报文丢失了，B 还在傻等 A 发送的数据，A 在等 B 的非零窗口通知。死锁产生了。所以引入持续计数器。只要收到零窗口通知，启动计数器，时间到期就发送一个探测报文，对方确认报文时给出当前的窗口大小，如果还是零，重新设置计数器，如果不是零， 则发送数据，打破死锁局面。

### 拥塞控制

发送方维持一个拥塞窗口的变量，受网络影响是动态变化的，发送放让发送窗口 = 拥塞窗口。考虑接收方处理能力，发送窗口可能小于拥塞窗口。

#### 慢开始

刚开始发送报文时，把拥塞窗口 cwnd 设置为一个最大报文段 MSS 的数值。每收到一个新的确认，把拥塞窗口增加至多一个 MSS 的数值。例如：开始时 cwnd = 1，发送报文段 M1，收到确认后把 cwnd 从 1 增加到 2，发送 M2，M3。收到两个确认后把 cwnd 从 2 增加到 4。每经过一个传输轮次，cwnd 就加倍。

#### 拥塞避免

每经过一个传输轮次 cwnd 不再是加倍，而是直接加 1。

+ 维护一个慢开始门限（ssthresh）的变量，大多数的 TCP 是吸纳来说，ssthresh 的值是 65535。。
+ 当 cwnd < ssthresh 时，使用慢开始算法。
+ 当 cwnd > ssthresh 时，改用拥塞避免算法。
+ 当 cwnd = ssthresh 时，慢开始与拥塞避免算法任意。
+ 当拥塞发生时（超时收到确认），ssthresh 会被设置为当前窗口大小的一半（ cwnd 和接收方通告窗口大小的最小值，但最少为 2个报文段）。此外 cwnd 会被设置为1个报文段执行慢开始算法。

#### 快重传

发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置重传计时器时间到期。发送 M1, M2, M3。M3 没有收到，又发了 M4, M5, M6 所以会收到对 M2 的三个重复确认。

#### 快恢复

当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 ssthresh 门限减半，但是接下去并不执行慢开始算法；

将 cwnd = ssthresh，直接进入拥塞避免算法。有的快重传会把窗口在增大，考虑到此时能连续收到 3 个ACK，说明网络没有拥塞，执行加法原则，有几个ACK就加几个报文段的字节数。

![](https://mubu.com/document_image/98a47313-45aa-432e-b999-fb01b5e648f0-803961.jpg)























